{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p>TypedRest helps you build type-safe, fluent-style REST API clients. Common REST patterns such as collections are represented as classes, allowing you to write more idiomatic code.</p> C#JavaKotlinTypeScript <pre><code>var client = new MyClient(new Uri(\"http://example.com/\"));\n\n// GET /contacts\nList&lt;Contact&gt; contactList = await client.Contacts.ReadAllAsync();\n\n// POST /contacts -&gt; Location: /contacts/1337\nContactEndpoint smith = await client.Contacts.CreateAsync(new Contact {Name = \"Smith\"});\n//ContactEndpoint smith = client.Contacts[\"1337\"];\n\n// GET /contacts/1337\nContact contact = await smith.ReadAsync();\n\n// PUT /contacts/1337/note\nawait smith.Note.SetAsync(new Note {Content = \"some note\"});\n\n// GET /contacts/1337/note\nNote note = await smith.Note.ReadAsync();\n\n// DELETE /contacts/1337\nawait smith.DeleteAsync();\n</code></pre> <pre><code>MyClient client = new MyClient(URI.create(\"http://example.com/\"));\n\n// GET /contacts\nList&lt;Contact&gt; contactList = client.getContacts().readAll();\n\n// POST /contacts -&gt; Location: /contacts/1337\nContactEndpoint smith = client.getContacts().create(new Contact(\"Smith\"));\n//ContactEndpoint smith = client.getContacts().get(\"1337\");\n\n// GET /contacts/1337\nContact contact = smith.read();\n\n// PUT /contacts/1337/note\nsmith.getNote().set(new Note(\"some note\"));\n\n// GET /contacts/1337/note\nNote note = smith.getNote().read();\n\n// DELETE /contacts/1337\nsmith.delete();\n</code></pre> <pre><code>val client = MyClient(URI.create(\"http://example.com/\"))\n\n// GET /contacts\nval contactList: List&lt;Contact&gt; = client.contacts.readAll()\n\n// POST /contacts -&gt; Location: /contacts/1337\nval smith: ContactEndpoint = client.contacts.create(Contact(\"Smith\"))\n//val smith: ContactEndpoint = client.contacts[\"1337\"]\n\n// GET /contacts/1337\nval contact: Contact = smith.read()\n\n// PUT /contacts/1337/note\nsmith.note.set(Note(\"some note\"))\n\n// GET /contacts/1337/note\nval note: Note = smith.note.read()\n\n// DELETE /contacts/1337\nsmith.delete()\n</code></pre> <pre><code>const client = new MyClient(new URL(\"http://example.com/\"));\n\n// GET /contacts\nconst contactList: Contact[] = await client.contacts.readAll();\n\n// POST /contacts -&gt; Location: /contacts/1337\nconst smith: ContactEndpoint = await client.contacts.create({name: \"Smith\"});\n//const smith: ContactEndpoint = client.contacts.get(\"1337\");\n\n// GET /contacts/1337\nconst contact: Contact = await smith.read();\n\n// PUT /contacts/1337/note\nawait smith.note.set({content: \"some note\"});\n\n// GET /contacts/1337/note\nconst note: Note = await smith.note.read();\n\n// DELETE /contacts/1337\nawait smith.delete();\n</code></pre>"},{"location":"#documentation","title":"Documentation","text":"Introduction What is TypedRest and how can it help me? Getting Started How do I use TypedRest in my projects? Endpoints Documentation for all endpoint types provided by TypedRest. Error handling How to handle API errors with TypedRest. Link handling How to handle relative URIs, link headers, HATEOS, etc. with TypedRest. Code generation Auto-generate code for TypedRest from Swagger/OpenAPI sepc."},{"location":"introduction/","title":"Introduction","text":"<p>There have been innumerable papers, posts and articles providing guidelines on how to design RESTful web services. Most of these guidelines are intended to make the behavior of web services more predictable for humans and machines alike. For example, the appropriate use of HTTP verbs allows developers to easily distinguish safe operations (such as <code>GET</code> and <code>HEAD</code>) from unsafe operations (such as <code>POST</code> and <code>DELETE</code>). Intermediate proxy servers can use this same information to determine candidates for caching. The plethora of HTTP headers provide many additional ways to express metadata and API structure in a standardized form.</p>"},{"location":"introduction/#the-old-way","title":"The \"old\" way","text":"<p>While this slowly evolving consensus on \"the right way\" to design new APIs makes understanding such APIs easier, it does not necessarily help when actually consuming them. While HTTP libraries and tools expose all the underlying components (HTTP verbs/methods, headers, etc.) the burden of actually interpreting and combining all the pieces still lies with the developer. Let us take a look at an example:</p> <p>Assume the URI <code>/contacts/</code> represents a collection of address book entries. <code>GET</code>ing the collection itself returns all entries. <code>GET</code>ing an URI like <code>/contacts/1337</code> gives you a specific entry. <code>POST</code>ing to the collection adds a new element to it and returns the URI of the newly created resource using the <code>Location</code> header.</p> <p>Pretty standard stuff, right? The problem is that all this knowledge currently only exists in your head. When you actually perform operations on the collection in your code you are usually manually building your <code>GET</code>s and your <code>POST</code>s while serializing and deserializing message bodies to and from JSON.</p> C#TypeScript <pre><code>var client = new HttpClient {BaseAddress = new Uri(\"http://example.com/\")};\n\nvar contactsResponse = await client.GetAsync(\"contacts\");\nvar contactList = await contactsResponse.Content.ReadAsAsync&lt;List&lt;Contact&gt;&gt;();\n\nvar createResponse = await client.PostAsJsonAsync(\"contacts\", new Contact {Name = \"Smith\"});\nvar contactUri = createResponse.Headers.Location;\n//var contactUri = new Uri(\"contacts/1337\", UriKind.Relative);\n\nvar contactResponse = await client.GetAsync(contactUri);\nvar contact = await contactResponse.Content.ReadAsAsync&lt;Contact&gt;();\n</code></pre> <pre><code>const contactsResponse = await fetch(\"http://example.com/contacts\");\nconst contactList = (await contactsResponse.json()) as Contact[];\n\nconst createResponse = await fetch(\"http://example.com/contacts\", {\n  body: JSON.stringify({name: \"Smith\"})\n});\nconst contactUri = createResponse.headers.get(\"Location\");\n//const contactUri = \"http://example.com/contacts/1337\"\n\nconst contactResponse = await fetch(contactUri);\nconst contact = (await contactResponse.json()) as Contact;\n</code></pre>"},{"location":"introduction/#better-with-typedrest","title":"Better with TypedRest","text":"<p>This is where TypedRest comes in. TypedRest is a set of libraries for consuming RESTful APIs that behave in a \"predictable\" way. Rather than applying your knowledge about how a REST collection usually behaves you simply tell TypedRest that this particular endpoint is a collection and get a collection-like interface in return.</p> C#TypeScript <pre><code>var client = new EntryEndpoint(new Uri(\"http://example.com/\"));\n\nvar contacts = new CollectionEndpoint&lt;Contact&gt;(client, relativeUri: \"./contacts\");\nvar contactList = await contacts.ReadAllAsync();\n\nvar smith = await contacts.CreateAsync(new Contact {Name = \"Smith\"});\n//var smith = contacts[\"1337\"];\n\nvar contact = await smith.ReadAsync();\n</code></pre> <pre><code>const client = new EntryEndpoint(new URL(\"http://example.com/\"));\n\nconst contacts = new CollectionEndpoint&lt;Contact&gt;(client, \"./contacts\");\nconst contactList = await contacts.readAll();\n\nconst smith = await contacts.create({name: \"Smith\"});\n//const smith = contacts.get(\"1337\");\n\nconst contact = await smith.read();\n</code></pre>"},{"location":"introduction/#endpoints","title":"Endpoints","text":"<p>TypedRest uses an object-oriented approach to provide you with building blocks for modeling RESTful endpoints. Behavior of endpoints is described by inheritance while navigation between them is described by composition. For example, we could redesign our sample from above to make the service's functionality easy to discover and consume using code completion:</p> C#TypeScript <pre><code>class MyClient(Uri uri) : EntryEndpoint(uri)\n{\n  public CollectionEndpoint&lt;Contact&gt; Contacts =&gt; new(this, relativeUri: \"./contacts\");\n}\n</code></pre> <pre><code>class MyClient extends EntryEndpoint {\n  get contacts() {\n    return new CollectionEndpoint&lt;Contact&gt;(this, \"./contacts\");\n  }\n}\n</code></pre> <p>The consuming code could look this:</p> C#TypeScript <pre><code>var client = new MyClient(new Uri(\"http://example.com/\"));\nvar contactList = await client.Contacts.ReadAllAsync();\nvar smith = await client.Contacts.CreateAsync(new Contact {Name = \"Smith\"});\nvar contact = await smith.ReadAsync();\n</code></pre> <pre><code>const client = new MyClient(new URL(\"http://example.com/\"));\nconst contactList = await client.contacts.readAll();\nconst smith = await client.contacts.create({name: \"Smith\"});\nconst contact = await smith.read();\n</code></pre>"},{"location":"introduction/#patterns","title":"Patterns","text":"<p>TypedRest is all about nomenclature and patterns. An endpoint describes any resource addressable via an URI.</p> <ul> <li>An entry endpoint represents the top-level URI of an API. It takes care of shared concerns such as authentication.</li> <li>An element endpoint is a singular resource that can be read, modified and deleted.</li> <li>A collection endpoint can list and add elements as well as provide element endpoints for individual elements.</li> </ul> <p>There are also a number of more specialized endpoint types such as streaming-capable collections. Each of these endpoint types has one or more corresponding classes in TypedRest. </p> <p>The only requirement on the server-side is that at least a part of the underlying pattern is implemented. For example, a collection endpoint class works as long as the server responds with an array of elements when <code>GET</code>ting the collection while <code>GET</code>ting a child endpoint provides a specific element of the same type. If adding new elements via <code>POST</code> is not supported (yet) this will simply result in an exception at runtime when calling <code>.CreateAsync()</code>. For more graceful degradation TypedRest also exposes information about \"allowed\" methods as reported by <code>OPTIONS</code>.</p> <p>We consider TypedRest's design to be opinionated yet pragmatic. The path of least resistance is to make your API match the patterns implemented in the built-in classes. These usually align with what is widely considered as \"best practice\". However:</p> <ul> <li>We explicitly support some unRESTful concepts such as RPC endpoints.</li> <li>HATEOAS-style, link-based navigation is possible but entirely optional.</li> <li>Link information is preferably encoded in HTTP Link headers instead of response bodies, although the latter is also supported in form of HAL.</li> <li>TypedRest does not use custom MIME types for API versioning, navigation, etc..</li> </ul> <p>Of course, we don't expect our predefined patterns to cover all possible use cases. This where good old \"extension through inheritance\" comes into play. Let's say our sample API from above also allows us to store a note associated with a contact. We need to extend <code>ElementEndpoint</code> for individual <code>Contact</code> instances to expose this functionality. We also need to replace <code>CollectionEndpoint</code> with something that builds instances of our specialized element endpoint rather than using <code>ElementEndpoint</code>. Let's get coding!</p> C#TypeScript <pre><code>class MyClient(Uri uri) : EntryEndpoint(uri)\n{\n  public ContactCollectionEndpoint Contacts =&gt; new(this);\n}\n\nclass ContactCollectionEndpoint(IEndpoint referrer)\n  : CollectionEndpoint&lt;Contact, ContactEndpoint&gt;(referrer, relativeUri: \"./contacts\");\n\nclass ContactEndpoint(IEndpoint referrer, Uri relativeUri)\n  : ElementEndpoint&lt;Contact&gt;(referrer, relativeUri)\n{\n  public ElementEndpoint&lt;Note&gt; Note =&gt; new(this, relativeUri: \"./note\");\n}\n</code></pre> <pre><code>class MyClient extends EntryEndpoint {\n  get contacts() {\n    return new ContactCollectionEndpoint(this);\n  }\n}\n\nclass ContactCollectionEndpoint extends GenericCollectionEndpoint&lt;Contact, ContactEndpoint&gt; {\n  constructor(referrer: Endpoint) {\n    super(referrer, \"./contacts\", ContactEndpoint);\n  }\n}\n\nclass ContactEndpoint extends ElementEndpoint&lt;Contact&gt; {\n  get note() {\n    return new ElementEndpoint&lt;Note&gt;(this, \"./note\");\n  }\n}\n</code></pre> <p>The consuming code could look this:</p> C#TypeScript <pre><code>var client = new MyClient(new Uri(\"http://example.com/\"));\nawait client.Contacts[\"1337\"].Note.SetAsync(new Note {Content = \"some note\"});\n</code></pre> <pre><code>const client = new MyClient(new URL(\"http://example.com/\"));\nawait client.contacts.get(\"1337\").note.set({content: \"some note\"});\n</code></pre>"},{"location":"introduction/#next-steps","title":"Next steps","text":"<p>Continue on to the Getting started guide.</p>"},{"location":"code-generation/","title":"Code generation","text":"<p>There is an experimental code generation tool available for TypedRest. This tool automatically infers TypedRest Endpoints from patterns in OpenAPI/Swagger documents and generates source code for TypedRest clients. It currently only supports generating C# clients.</p> <p>Take a look at the project's GitHub repository.</p>"},{"location":"endpoints/","title":"Endpoint types","text":"<p>Endpoints are the main building blocks of TypedRest. An endpoint represents an URI that provides methods for interacting with a specific resource. The type of the endpoint determines the available methods. An endpoint can also provide child endpoints (represent child URIs) via composition.</p> <p>TypedRest provides a number of endpoint types modelling common REST patterns. Most APIs can be consumed by either directly using these types or by deriving from them and adding additional methods for special use cases.</p> <p>Entry endpoints represent the top-level URI of APIs.</p> <p>Generic endpoints allow you to model collections and elements:</p> <ul> <li>Element endpoint - individual resource (read, write, delete)</li> <li>Collection endpoint - collection of entities addressable as elements (read all, create, get child by ID)</li> <li>Indexer endpoint - address child endpoints by ID</li> </ul> <p>RPC endpoints allow you to interact with non-RESTful resources that act like callable functions:</p> <ul> <li>Action endpoint - no input or output</li> <li>Consumer endpoint - takes entity as input</li> <li>Producer endpoint - produces entity as output</li> <li>Function endpoint - takes entity as input and produces entity as output</li> </ul> <p>Raw endpoints allow you to transmit binary data rather than serialized objects:</p> <ul> <li>Upload endpoint - accept binary uploads</li> <li>Blob endpoint - download or upload a binary blob</li> </ul> <p>Reactive endpoints allow you to receive data as push streams rather than explicitly pulling:</p> <ul> <li>Polling endpoint - poll resource for state changes</li> <li>Streaming endpoint - stream of entities via persistent connection</li> <li>Streaming Collection endpoint - collection of entities observable as append-only stream</li> </ul> <p>The constructors of all endpoints except entry endpoints take a <code>referrer</code> parameter. This is uses to inherit relative URI bases and configuration such as error handling and link handling.</p>"},{"location":"endpoints/entry/","title":"Entry endpoint","text":"<p>Represent the top-level URI of an API. Used to address the various resources of the API.</p> <p>The constructor of the entry endpoint requires you to specify the APIs root URL. It also provides optional parameters to override the default HTTP client, JSON serializer, error handler and link handler.</p>"},{"location":"endpoints/generic/collection/","title":"Collection endpoint","text":"<p>Endpoint for a collection of entities addressable as Element endpoints.</p> Method Input Result HTTP Verb Description Get ID / Entity Endpoint - Get an Element endpoint for a specific child element. Read all - Entities <code>GET</code> Returns all entities in the collection. Read range Range Entities <code>GET</code> Returns all entities within a specific range of the collection. Create Entity - <code>POST</code> Adds an entity as a new element to the collection. Create All Entities - <code>PATCH</code> Adds (or updates) multiple entities as elements in the collection. Set All Entities - <code>PUT</code> Replaces the entire content of the collection with new entities. <p>Extends Indexer endpoint</p>"},{"location":"endpoints/generic/element/","title":"Element endpoint","text":"<p>Endpoint for an individual resource.</p> Method Input Result HTTP Verb Description Exists - Boolean <code>HEAD</code> Determines whether the element currently exists. Read - Entity <code>GET</code> Returns the entity. Set Entity Entity <code>PUT</code> Sets/replaces the entity. Merge Entity Entity <code>PATCH</code> Modifies the existing entity by merging changes. Delete - - <code>DELETE</code> Deletes the element."},{"location":"endpoints/generic/indexer/","title":"Indexer endpoint","text":"<p>Endpoint that addresses child endpoints by ID.</p> Method Input Result HTTP Verb Description Get ID Endpoint - Get an Element endpoint for a specific child element."},{"location":"endpoints/raw/blob/","title":"Blob endpoint","text":"<p>Endpoint for a binary blob that can be downloaded or uploaded.</p> Method Input Result HTTP Verb Description Download - Binary data <code>GET</code> Downloads the blob's content. Upload Binary data - <code>PUT</code> Uploads content for the blob."},{"location":"endpoints/raw/upload/","title":"Upload endpoint","text":"<p>Endpoint that accepts binary uploads.</p> Method Input Result HTTP Verb Description Upload Binary data - <code>POST</code> Uploads data to the endpoint."},{"location":"endpoints/reactive/polling/","title":"Polling endpoint","text":"<p>Endpoint for a resource that can be polled for state changes.</p> Method Input Result HTTP Verb Description Get observable - Entity stream <code>GET</code> Provides an observable stream of entity states. Exists - Boolean <code>HEAD</code> Determines whether the element currently exists. Read - Entity <code>GET</code> Returns the entity. Set Entity Entity <code>PUT</code> Sets/replaces the entity. Merge Entity Entity <code>PATCH</code> Modifies the existing entity by merging changes. Delete - - <code>DELETE</code> Deletes the element. <p>Extends Element endpoint</p>"},{"location":"endpoints/reactive/streaming-collection/","title":"Streaming Collection endpoint","text":"<p>Endpoint for a collection of entities observable as an append-only stream using long-polling.</p> Method Input Result HTTP Verb Description Get observable - Entity stream <code>GET</code> Provides an observable stream of elements. Get ID / Entity Endpoint - Get an Element endpoint for a specific child element. Read all - Entities <code>GET</code> Returns all entities in the collection. Read range Range Entities <code>GET</code> Returns all entities within a specific range of the collection. Create Entity - <code>POST</code> Adds an entity as a new element to the collection. Create All Entities - <code>PATCH</code> Adds (or updates) multiple entities as elements in the collection. Set All Entities - <code>PUT</code> Replaces the entire content of the collection with new entities. <p>Extends Collection endpoint</p>"},{"location":"endpoints/reactive/streaming/","title":"Streaming endpoint","text":"<p>Endpoint for a stream of entities using a persistent HTTP connection.</p> Method Input Result HTTP Verb Description Get observable - Entity stream <code>GET</code> Provides an observable stream of entities."},{"location":"endpoints/rpc/action/","title":"Action endpoint","text":"<p>RPC endpoint that is invoked with no input or output.</p> Method Input Result HTTP Verb Description Invoke - - <code>POST</code> Invokes the action."},{"location":"endpoints/rpc/consumer/","title":"Consumer endpoint","text":"<p>RPC endpoint that takes an entity as input when invoked.</p> Method Input Result HTTP Verb Description Invoke Entity - <code>POST</code> Sends the entity to the consumer."},{"location":"endpoints/rpc/function/","title":"Function endpoint","text":"<p>RPC endpoint that takes an entity as input and returns another entity as output when invoked.</p> Method Input Result HTTP Verb Description Invoke Entity Entity <code>POST</code> Invokes the function."},{"location":"endpoints/rpc/producer/","title":"Producer endpoint","text":"<p>RPC endpoint that returns an entity as output when invoked.</p> Method Input Result HTTP Verb Description Invoke - Entity <code>POST</code> Gets an entity from the producer."},{"location":"error-handling/","title":"Exception mapping","text":"<p>TypedRest maps non-success HTTP Status (4xx and 5xx) to exceptions/errors. The following mappings are applied by default:</p> HTTP Status Code .NET Exception JavaScript Error 400 Bad Request <code>InvalidDataException</code> <code>BadRequestError</code> 401 Unauthorized <code>AuthenticationException</code> <code>AuthenticationError</code> 403 Forbidden <code>UnauthorizedAccessException</code> <code>AuthorizationError</code> 404 NotFound or 410 Gone <code>KeyNotFoundException</code> <code>NotFoundError</code> 408 Request Timeout <code>TimeoutException</code> <code>TimeoutError</code> 409 Conflict <code>InvalidOperationException</code> <code>ConflictError</code> 412 Precondition Failed <code>InvalidOperationException</code> <code>ConcurrencyError</code> 416 Range Not Satisfiable <code>InvalidOperationException</code> <code>RangeError</code> other <code>HttpRequestException</code> <code>HttpError</code>"},{"location":"getting-started/","title":"Getting started","text":"<p>TypedRest is available for multiple platforms/languages. Please choose one of the following Getting Started Guides:</p> <ul> <li>.NET (C#, VB.NET, F#, etc.)</li> <li>Java (Java and Kotlin)</li> <li>TypeScript</li> </ul>"},{"location":"getting-started/dotnet/","title":".NET","text":""},{"location":"getting-started/dotnet/#dependencies","title":"Dependencies","text":"<p>Add one or more of the following NuGet packages to your project:</p> <p>TypedRest The main TypedRest library.</p> <p>TypedRest.Reactive Adds support for streaming with ReactiveX (Rx) to TypedRest.</p> <p>TypedRest.OAuth Provides an HttpClient DelegatingHandler for OAuth 2.0 / OpenID Connect authentication. This can also be used independently of the other TypedRest packages.</p> <p>TypedRest.CommandLine Build command-line interfaces for TypedRest clients.</p>"},{"location":"getting-started/dotnet/#dependency-injection","title":"Dependency Injection","text":"<p>If you wish to use TypedRest in an ASP.NET Core web service (or any other kind of service that uses <code>IServiceProvider</code>-based dependency injection) you can use the <code>.AddTypedRest&lt;T&gt;()</code> extension method. This registers the endpoint you specify for dependency injection and connects it with HttpClientFactory.</p>"},{"location":"getting-started/dotnet/#see-also","title":"See also","text":"<ul> <li>API documentation</li> <li>GitHub repository</li> <li>Sample project</li> </ul>"},{"location":"getting-started/java/","title":"Java","text":""},{"location":"getting-started/java/#dependencies","title":"Dependencies","text":"<p>Add one or more of the following Maven artifacts to your project:</p> <p>typedrest-core The main TypedRest library.</p> <p>typedrest-annotations Annotations for data models to be used with TypedRest.</p> <p>typedrest-vaadin Build Vaadin GUIs for TypedRest clients.</p>"},{"location":"getting-started/java/#see-also","title":"See also","text":"<ul> <li>API documentation</li> <li>GitHub repository</li> </ul>"},{"location":"getting-started/typescript/","title":"TypeScript","text":""},{"location":"getting-started/typescript/#dependencies","title":"Dependencies","text":"<p>Add the <code>typescript</code> NPM package to your project:</p> <pre><code>npm install typedrest --save\n</code></pre>"},{"location":"getting-started/typescript/#see-also","title":"See also","text":"<ul> <li>API documentation</li> <li>GitHub repository</li> </ul>"},{"location":"link-handling/","title":"Link handling","text":"<p>TypedRest supports a variety of different links:</p> <ul> <li>Hard-coded relative URIs between endpoints</li> <li>Links transmitted via the HTTP Link Header</li> <li>Links encoded in resources via HAL</li> <li>URI templates</li> </ul>"}]}