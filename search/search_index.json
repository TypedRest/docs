{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Home","text":"<p>TypedRest helps you build type-safe, fluent-style REST API clients. Common REST patterns such as collections are represented as classes, allowing you to write more idiomatic code.</p> C#JavaKotlinTypeScript <pre><code>var client = new MyClient(new Uri(\"http://example.com/\"));\n\n// GET /contacts\nList&lt;Contact&gt; contactList = await client.Contacts.ReadAllAsync();\n\n// POST /contacts -&gt; Location: /contacts/1337\nContactEndpoint smith = await client.Contacts.CreateAsync(new Contact {Name = \"Smith\"});\n//ContactEndpoint smith = client.Contacts[\"1337\"];\n\n// GET /contacts/1337\nContact contact = await smith.ReadAsync();\n\n// PUT /contacts/1337/note\nawait smith.Note.SetAsync(new Note {Content = \"some note\"});\n\n// GET /contacts/1337/note\nNote note = await smith.Note.ReadAsync();\n\n// DELETE /contacts/1337\nawait smith.DeleteAsync();\n</code></pre> <pre><code>MyClient client = new MyClient(URI.create(\"http://example.com/\"));\n\n// GET /contacts\nList&lt;Contact&gt; contactList = client.getContacts().readAll();\n\n// POST /contacts -&gt; Location: /contacts/1337\nContactEndpoint smith = client.getContacts().create(new Contact(\"Smith\"));\n//ContactEndpoint smith = client.getContacts().get(\"1337\");\n\n// GET /contacts/1337\nContact contact = smith.read();\n\n// PUT /contacts/1337/note\nsmith.getNote().set(new Note(\"some note\"));\n\n// GET /contacts/1337/note\nNote note = smith.getNote().read();\n\n// DELETE /contacts/1337\nsmith.delete();\n</code></pre> <pre><code>val client = MyClient(URI.create(\"http://example.com/\"))\n\n// GET /contacts\nval contactList: List&lt;Contact&gt; = client.contacts.readAll()\n\n// POST /contacts -&gt; Location: /contacts/1337\nval smith: ContactEndpoint = client.contacts.create(Contact(\"Smith\"))\n//val smith: ContactEndpoint = client.contacts[\"1337\"]\n\n// GET /contacts/1337\nval contact: Contact = smith.read()\n\n// PUT /contacts/1337/note\nsmith.note.set(Note(\"some note\"))\n\n// GET /contacts/1337/note\nval note: Note = smith.note.read()\n\n// DELETE /contacts/1337\nsmith.delete()\n</code></pre> <pre><code>const client = new MyClient(new URL(\"http://example.com/\"));\n\n// GET /contacts\nconst contactList: Contact[] = await client.contacts.readAll();\n\n// POST /contacts -&gt; Location: /contacts/1337\nconst smith: ContactEndpoint = await client.contacts.create({name: \"Smith\"});\n//const smith: ContactEndpoint = client.contacts.get(\"1337\");\n\n// GET /contacts/1337\nconst contact: Contact = await smith.read();\n\n// PUT /contacts/1337/note\nawait smith.note.set({content: \"some note\"});\n\n// GET /contacts/1337/note\nconst note: Note = await smith.note.read();\n\n// DELETE /contacts/1337\nawait smith.delete();\n</code></pre>"},{"location":"#documentation","title":"Documentation","text":"Introduction What is TypedRest and how can it help me? Setup How do I use TypedRest in my projects? Endpoints Documentation for all endpoint types provided by TypedRest. Serializers How to convert objects to and from the wire format (e.g., JSON). Error handling How to handle API errors with TypedRest. Link handling How to handle relative URIs, link headers, HATEOS, etc. with TypedRest. Code generation Auto-generate code for TypedRest from Swagger/OpenAPI sepc."},{"location":"imprint/","title":"Imprint","text":"<p>Bastian Eicher Sophienstr. 121 76135 Karlsruhe Germany</p> <p>E-Mail: info@typedrest.net Phone: +49-721-66530941</p>"},{"location":"introduction/","title":"Introduction","text":"<p>There have been innumerable papers, posts and articles providing guidelines on how to design RESTful web services. Most of these guidelines are intended to make the behavior of web services more predictable for humans and machines alike. For example, the appropriate use of HTTP verbs allows developers to easily distinguish safe operations (such as <code>GET</code> and <code>HEAD</code>) from unsafe operations (such as <code>POST</code> and <code>DELETE</code>). Intermediate proxy servers can use this same information to determine candidates for caching. The plethora of HTTP headers provide many additional ways to express metadata and API structure in a standardized form.</p>"},{"location":"introduction/#the-old-way","title":"The \"old\" way","text":"<p>While this slowly evolving consensus on \"the right way\" to design new APIs makes understanding such APIs easier, it does not necessarily help when actually consuming them. While HTTP libraries and tools expose all the underlying components (HTTP verbs/methods, headers, etc.) the burden of actually interpreting and combining all the pieces still lies with the developer. Let us take a look at an example:</p> <p>Assume the URI <code>/contacts/</code> represents a collection of address book entries. <code>GET</code>ing the collection itself returns all entries. <code>GET</code>ing an URI like <code>/contacts/1337</code> gives you a specific entry. <code>POST</code>ing to the collection adds a new element to it and returns the URI of the newly created resource using the <code>Location</code> header.</p> <p>Pretty standard stuff, right? The problem is that all this knowledge currently only exists in your head. When you actually perform operations on the collection in your code you are usually manually building your <code>GET</code>s and your <code>POST</code>s while serializing and deserializing message bodies to and from JSON.</p> C#JavaKotlinTypeScript <pre><code>var client = new HttpClient {BaseAddress = new Uri(\"http://example.com/\")};\n\nvar contactsResponse = await client.GetAsync(\"contacts\");\nvar contactList = await contactsResponse.Content.ReadAsAsync&lt;List&lt;Contact&gt;&gt;();\n\nvar createResponse = await client.PostAsJsonAsync(\"contacts\", new Contact {Name = \"Smith\"});\nvar contactUri = createResponse.Headers.Location;\n//var contactUri = new Uri(\"contacts/1337\", UriKind.Relative);\n\nvar contactResponse = await client.GetAsync(contactUri);\nvar contact = await contactResponse.Content.ReadAsAsync&lt;Contact&gt;();\n</code></pre> <pre><code>HttpClient client = HttpClient.newBuilder()\n    .build();\n\nHttpRequest contactsRequest = HttpRequest.newBuilder()\n    .uri(URI.create(\"http://example.com/contacts\"))\n    .GET()\n    .build();\nHttpResponse&lt;String&gt; contactsResponse = client.send(contactsRequest, HttpResponse.BodyHandlers.ofString());\nList&lt;Contact&gt; contactList = objectMapper.readValue(contactsResponse.body(), new TypeReference&lt;List&lt;Contact&gt;&gt;() {});\n\nString requestBody = objectMapper.writeValueAsString(new Contact(\"Smith\"));\nHttpRequest createRequest = HttpRequest.newBuilder()\n    .uri(URI.create(\"http://example.com/contacts\"))\n    .POST(HttpRequest.BodyPublishers.ofString(requestBody))\n    .build();\nHttpResponse&lt;String&gt; createResponse = client.send(createRequest, HttpResponse.BodyHandlers.ofString());\nURI contactUri = URI.create(createResponse.headers().firstValue(\"Location\").get());\n//URI contactUri = URI.create(\"contacts/1337\");\n\nHttpRequest contactRequest = HttpRequest.newBuilder()\n    .uri(contactUri)\n    .GET()\n    .build();\nHttpResponse&lt;String&gt; contactResponse = client.send(contactRequest, HttpResponse.BodyHandlers.ofString());\nContact contact = objectMapper.readValue(contactResponse.body(), Contact.class);\n</code></pre> <pre><code>val client = HttpClient.newBuilder()\n    .build()\n\nval contactsRequest = HttpRequest.newBuilder()\n    .uri(URI.create(\"http://example.com/contacts\"))\n    .GET()\n    .build()\nval contactsResponse = client.send(contactsRequest, HttpResponse.BodyHandlers.ofString())\nval contactList = objectMapper.readValue&lt;List&lt;Contact&gt;&gt;(contactsResponse.body())\n\nval requestBody = objectMapper.writeValueAsString(Contact(\"Smith\"))\nval createRequest = HttpRequest.newBuilder()\n    .uri(URI.create(\"http://example.com/contacts\"))\n    .POST(HttpRequest.BodyPublishers.ofString(requestBody))\n    .build()\nval createResponse = client.send(createRequest, HttpResponse.BodyHandlers.ofString())\nval contactUri = URI.create(createResponse.headers().firstValue(\"Location\").get())\n//val contactUri = URI.create(\"contacts/1337\")\n\nval contactRequest = HttpRequest.newBuilder()\n    .uri(contactUri)\n    .GET()\n    .build()\nval contactResponse = client.send(contactRequest, HttpResponse.BodyHandlers.ofString())\nval contact = objectMapper.readValue&lt;Contact&gt;(contactResponse.body())\n</code></pre> <pre><code>const contactsResponse = await fetch(\"http://example.com/contacts\");\nconst contactList = (await contactsResponse.json()) as Contact[];\n\nconst createResponse = await fetch(\"http://example.com/contacts\", {\n  body: JSON.stringify({name: \"Smith\"})\n});\nconst contactUri = createResponse.headers.get(\"Location\");\n//const contactUri = \"http://example.com/contacts/1337\"\n\nconst contactResponse = await fetch(contactUri);\nconst contact = (await contactResponse.json()) as Contact;\n</code></pre>"},{"location":"introduction/#better-with-typedrest","title":"Better with TypedRest","text":"<p>This is where TypedRest comes in. TypedRest is a set of libraries for consuming RESTful APIs that behave in a \"predictable\" way. Rather than applying your knowledge about how a REST collection usually behaves you simply tell TypedRest that this particular endpoint is a collection and get a collection-like interface in return.</p> C#JavaKotlinTypeScript <pre><code>var client = new EntryEndpoint(new Uri(\"http://example.com/\"));\n\nvar contacts = new CollectionEndpoint&lt;Contact&gt;(client, relativeUri: \"./contacts\");\nvar contactList = await contacts.ReadAllAsync();\n\nvar smith = await contacts.CreateAsync(new Contact {Name = \"Smith\"});\n//var smith = contacts[\"1337\"];\n\nvar contact = await smith.ReadAsync();\n</code></pre> <pre><code>EntryEndpoint client = new EntryEndpoint(URI.create(\"http://example.com/\"));\n\nCollectionEndpoint&lt;Contact&gt; contacts = new CollectionEndpointImpl&lt;&gt;(client, \"./contacts\", Contact.class);\nList&lt;Contact&gt; contactList = contacts.readAll();\n\nElementEndpoint&lt;Contact&gt; smith = contacts.create(new Contact(\"Smith\"));\n//ElementEndpoint&lt;Contact&gt; smith = contacts.get(\"1337\");\n\nContact contact = smith.read();\n</code></pre> <pre><code>val client = EntryEndpoint(URI.create(\"http://example.com/\"))\n\nval contacts = CollectionEndpointImpl(client, \"./contacts\", Contact::class.java)\nval contactList = contacts.readAll()\n\nval smith = contacts.create(Contact(\"Smith\"))\n//val smith = contacts[\"1337\"]\n\nval contact = smith.read()\n</code></pre> <pre><code>const client = new EntryEndpoint(new URL(\"http://example.com/\"));\n\nconst contacts = new CollectionEndpoint&lt;Contact&gt;(client, \"./contacts\");\nconst contactList = await contacts.readAll();\n\nconst smith = await contacts.create({name: \"Smith\"});\n//const smith = contacts.get(\"1337\");\n\nconst contact = await smith.read();\n</code></pre>"},{"location":"introduction/#endpoints","title":"Endpoints","text":"<p>TypedRest uses an object-oriented approach to provide you with building blocks for modeling RESTful endpoints. Behavior of endpoints is described by inheritance while navigation between them is described by composition. For example, we could redesign our sample from above to make the service's functionality easy to discover and consume using code completion:</p> C#JavaKotlinTypeScript <pre><code>class MyClient(Uri uri) : EntryEndpoint(uri)\n{\n  public CollectionEndpoint&lt;Contact&gt; Contacts =&gt; new(this, relativeUri: \"./contacts\");\n}\n</code></pre> <pre><code>class MyClient extends EntryEndpoint {\n  public MyClient(URI uri) {\n    super(uri);\n  }\n\n  public CollectionEndpoint&lt;Contact&gt; getContacts() {\n    return new CollectionEndpointImpl&lt;&gt;(this, \"./contacts\", Contact.class);\n  }\n}\n</code></pre> <pre><code>class MyClient(uri: URI) : EntryEndpoint(uri) {\n  val contacts: CollectionEndpoint&lt;Contact&gt;\n    get() = CollectionEndpointImpl(this, \"./contacts\", Contact::class.java)\n}\n</code></pre> <pre><code>class MyClient extends EntryEndpoint {\n  get contacts() {\n    return new CollectionEndpoint&lt;Contact&gt;(this, \"./contacts\");\n  }\n}\n</code></pre> <p>The consuming code could look this:</p> C#JavaKotlinTypeScript <pre><code>var client = new MyClient(new Uri(\"http://example.com/\"));\nvar contactList = await client.Contacts.ReadAllAsync();\nvar smith = await client.Contacts.CreateAsync(new Contact {Name = \"Smith\"});\nvar contact = await smith.ReadAsync();\n</code></pre> <pre><code>MyClient client = new MyClient(URI.create(\"http://example.com/\"));\nList&lt;Contact&gt; contactList = client.getContacts().readAll();\nElementEndpoint&lt;Contact&gt; smith = client.getContacts().create(new Contact(\"Smith\"));\nContact contact = smith.read();\n</code></pre> <pre><code>val client = MyClient(URI.create(\"http://example.com/\"))\nval contactList = client.contacts.readAll()\nval smith = client.contacts.create(Contact(\"Smith\"))\nval contact = smith.read()\n</code></pre> <pre><code>const client = new MyClient(new URL(\"http://example.com/\"));\nconst contactList = await client.contacts.readAll();\nconst smith = await client.contacts.create({name: \"Smith\"});\nconst contact = await smith.read();\n</code></pre>"},{"location":"introduction/#patterns","title":"Patterns","text":"<p>TypedRest is all about nomenclature and patterns. An endpoint describes any resource addressable via an URI.</p> <ul> <li>An entry endpoint represents the top-level URI of an API. It takes care of shared concerns such as authentication.</li> <li>An element endpoint is a singular resource that can be read, modified and deleted.</li> <li>A collection endpoint can list and add elements as well as provide element endpoints for individual elements.</li> </ul> <p>There are also a number of more specialized endpoint types such as streaming-capable collections. Each of these endpoint types has one or more corresponding classes in TypedRest. </p> <p>The only requirement on the server-side is that at least a part of the underlying pattern is implemented. For example, a collection endpoint class works as long as the server responds with an array of elements when <code>GET</code>ting the collection while <code>GET</code>ting a child endpoint provides a specific element of the same type. If adding new elements via <code>POST</code> is not supported (yet) this will simply result in an exception at runtime when calling <code>.CreateAsync()</code>. For more graceful degradation TypedRest also exposes information about \"allowed\" methods as reported by <code>OPTIONS</code>.</p> <p>We consider TypedRest's design to be opinionated yet pragmatic. The path of least resistance is to make your API match the patterns implemented in the built-in classes. These usually align with what is widely considered as \"best practice\". However:</p> <ul> <li>We explicitly support some unRESTful concepts such as RPC endpoints.</li> <li>HATEOAS-style, link-based navigation is possible but entirely optional.</li> <li>Link information is preferably encoded in HTTP Link headers instead of response bodies, although the latter is also supported in form of HAL.</li> <li>TypedRest does not use custom MIME types for API versioning, navigation, etc..</li> </ul> <p>Of course, we don't expect our predefined patterns to cover all possible use cases. This where good old \"extension through inheritance\" comes into play. Let's say our sample API from above also allows us to store a note associated with a contact. We need to extend <code>ElementEndpoint</code> for individual <code>Contact</code> instances to expose this functionality. We also need to replace <code>CollectionEndpoint</code> with something that builds instances of our specialized element endpoint rather than using <code>ElementEndpoint</code>. Let's get coding!</p> C#JavaKotlinTypeScript <pre><code>class MyClient(Uri uri) : EntryEndpoint(uri)\n{\n  public ContactCollectionEndpoint Contacts =&gt; new(this);\n}\n\nclass ContactCollectionEndpoint(IEndpoint referrer)\n  : CollectionEndpoint&lt;Contact, ContactEndpoint&gt;(referrer, relativeUri: \"./contacts\");\n\nclass ContactEndpoint(IEndpoint referrer, Uri relativeUri)\n  : ElementEndpoint&lt;Contact&gt;(referrer, relativeUri)\n{\n  public ElementEndpoint&lt;Note&gt; Note =&gt; new(this, relativeUri: \"./note\");\n}\n</code></pre> <pre><code>class MyClient extends EntryEndpoint {\n  public MyClient(URI uri) {\n    super(uri);\n  }\n\n  public ContactCollectionEndpoint getContacts() {\n    return new ContactCollectionEndpoint(this);\n  }\n}\n\nclass ContactCollectionEndpoint extends GenericCollectionEndpointImpl&lt;Contact, ContactEndpoint&gt; {\n  public ContactCollectionEndpoint(Endpoint referrer) {\n    super(referrer, \"./contacts\", Contact.class, ContactEndpoint::new);\n  }\n}\n\nclass ContactEndpoint extends ElementEndpointImpl&lt;Contact&gt; {\n  public ContactEndpoint(Endpoint referrer, URI relativeUri) {\n    super(referrer, relativeUri, Contact.class);\n  }\n\n  public ElementEndpoint&lt;Note&gt; getNote() {\n    return new ElementEndpointImpl&lt;&gt;(this, \"./note\", Note.class);\n  }\n}\n</code></pre> <pre><code>class MyClient(uri: URI) : EntryEndpoint(uri) {\n  val contacts: ContactCollectionEndpoint\n    get() = ContactCollectionEndpoint(this)\n}\n\nclass ContactCollectionEndpoint(referrer: Endpoint) :\n  GenericCollectionEndpointImpl&lt;Contact, ContactEndpoint&gt;(referrer, \"./contacts\", Contact::class.java, ::ContactEndpoint)\n\nclass ContactEndpoint(referrer: Endpoint, relativeUri: URI) :\n  ElementEndpointImpl&lt;Contact&gt;(referrer, relativeUri, Contact::class.java) {\n  val note: ElementEndpoint&lt;Note&gt;\n    get() = ElementEndpointImpl(this, \"./note\", Note::class.java)\n}\n</code></pre> <pre><code>class MyClient extends EntryEndpoint {\n  get contacts() {\n    return new ContactCollectionEndpoint(this);\n  }\n}\n\nclass ContactCollectionEndpoint extends GenericCollectionEndpoint&lt;Contact, ContactEndpoint&gt; {\n  constructor(referrer: Endpoint) {\n    super(referrer, \"./contacts\", ContactEndpoint);\n  }\n}\n\nclass ContactEndpoint extends ElementEndpoint&lt;Contact&gt; {\n  get note() {\n    return new ElementEndpoint&lt;Note&gt;(this, \"./note\");\n  }\n}\n</code></pre> <p>The consuming code could look this:</p> C#JavaKotlinTypeScript <pre><code>var client = new MyClient(new Uri(\"http://example.com/\"));\nawait client.Contacts[\"1337\"].Note.SetAsync(new Note {Content = \"some note\"});\n</code></pre> <pre><code>MyClient client = new MyClient(URI.create(\"http://example.com/\"));\nclient.getContacts().get(\"1337\").getNote().set(new Note(\"some note\"));\n</code></pre> <pre><code>val client = MyClient(URI.create(\"http://example.com/\"))\nclient.contacts[\"1337\"].note.set(Note(\"some note\"))\n</code></pre> <pre><code>const client = new MyClient(new URL(\"http://example.com/\"));\nawait client.contacts.get(\"1337\").note.set({content: \"some note\"});\n</code></pre>"},{"location":"introduction/#next-steps","title":"Next steps","text":"<p>Continue on to the Setup guide.</p>"},{"location":"code-generation/","title":"Code generation","text":"<p>There is an experimental code generation tool available for TypedRest. This tool automatically infers TypedRest Endpoints from patterns in OpenAPI/Swagger documents and generates source code for TypedRest clients. It currently only supports generating C# clients.</p> <p>Take a look at the project's GitHub repository.</p>"},{"location":"endpoints/","title":"Endpoint types","text":"<p>Endpoints are the main building blocks of TypedRest. An endpoint represents an URI that provides methods for interacting with a specific resource. The type of the endpoint determines the available methods. An endpoint can also provide child endpoints (represent child URIs) via composition.</p> <p>TypedRest provides a number of endpoint types modelling common REST patterns. Most APIs can be consumed by either directly using these types or by deriving from them and adding additional methods for special use cases.</p> <p>Entry endpoints represent the top-level URI of APIs.</p> <p>Generic endpoints allow you to model collections and elements:</p> <ul> <li>Element endpoint - individual resource (read, write, delete)</li> <li>Collection endpoint - collection of entities addressable as elements (read all, create, get child by ID)</li> <li>Indexer endpoint - address child endpoints by ID</li> </ul> <p>RPC endpoints allow you to interact with non-RESTful resources that act like callable functions:</p> <ul> <li>Action endpoint - no input or output</li> <li>Consumer endpoint - takes entity as input</li> <li>Producer endpoint - produces entity as output</li> <li>Function endpoint - takes entity as input and produces entity as output</li> </ul> <p>Raw endpoints allow you to transmit binary data rather than serialized objects:</p> <ul> <li>Upload endpoint - accept binary uploads</li> <li>Blob endpoint - download or upload a binary blob</li> </ul> <p>Reactive endpoints allow you to receive data as push streams rather than explicitly pulling:</p> <ul> <li>Polling endpoint - poll resource for state changes</li> <li>Streaming endpoint - stream of entities via persistent connection</li> <li>Streaming Collection endpoint - collection of entities observable as append-only stream</li> </ul> <p>The constructors of all endpoints (except entry endpoints) take a <code>referrer</code> parameter. This is used to inherit relative URI bases, serializers and error handling.</p>"},{"location":"endpoints/entry/","title":"Entry endpoint","text":"<p>Represent the top-level URI of an API. Used to address the various resources of the API.</p> <p>The constructor of the entry endpoint requires you to specify the APIs root URL. It also provides optional parameters to override the default HTTP client, JSON serializer, error handler and link handler.</p>"},{"location":"endpoints/entry/#usage","title":"Usage","text":"C#JavaKotlinTypeScript <pre><code>// Create an entry endpoint\nvar client = new EntryEndpoint(new Uri(\"http://example.com/api/\"));\n\n// Create child endpoint\nvar contacts = new CollectionEndpoint&lt;Contact&gt;(client, \"contacts\");\n</code></pre> <pre><code>// Create an entry endpoint\nEntryEndpoint client = new EntryEndpoint(URI.create(\"http://example.com/api/\"));\n\n// Create child endpoint\nCollectionEndpoint&lt;Contact&gt; contacts = new CollectionEndpoint&lt;&gt;(client, \"contacts\", Contact.class);\n</code></pre> <pre><code>// Create an entry endpoint\nval client = EntryEndpoint(URI.create(\"http://example.com/api/\"))\n\n// Create child endpoint\nval contacts = CollectionEndpoint(client, \"contacts\", Contact::class.java)\n</code></pre> <pre><code>// Create an entry endpoint\nconst client = new EntryEndpoint(new URL(\"http://example.com/api/\"));\n\n// Create child endpoint\nconst contacts = new CollectionEndpoint&lt;Contact&gt;(client, \"contacts\");\n</code></pre>"},{"location":"endpoints/generic/collection/","title":"Collection endpoint","text":"<p>Endpoint for a collection of entities addressable as Element endpoints.</p> Method Input Result HTTP Verb Description Get ID / Entity Endpoint - Get an Element endpoint for a specific child element. Read all - Entities <code>GET</code> Returns all entities in the collection. Read range Range Entities <code>GET</code> Returns all entities within a specific range of the collection. Create Entity - <code>POST</code> Adds an entity as a new element to the collection. Create All Entities - <code>PATCH</code> Adds (or updates) multiple entities as elements in the collection. Set All Entities - <code>PUT</code> Replaces the entire content of the collection with new entities. <p>Extends Indexer endpoint</p>"},{"location":"endpoints/generic/collection/#usage","title":"Usage","text":"C#JavaKotlinTypeScript <pre><code>var contacts = new CollectionEndpoint&lt;Contact&gt;(client, \"contacts\");\n\n// Read all entities in the collection\nList&lt;Contact&gt; allContacts = await contacts.ReadAllAsync();\n\n// Read a range of entities\nPartialResponse&lt;Contact&gt; someContacts = await contacts.ReadRangeAsync(new RangeItemHeaderValue(0, 49));\n\n// Create a new entity\nElementEndpoint&lt;Contact&gt; newContact = await contacts.CreateAsync(new Contact { Name = \"John Doe\" });\n\n// Get an element by ID\nElementEndpoint&lt;Contact&gt; contact = contacts[\"123\"];\n\n// Update multiple entities\nawait contacts.CreateAllAsync([\n    new Contact { Name = \"Alice\" },\n    new Contact { Name = \"Bob\" }\n]);\n\n// Replace entire collection\nawait contacts.SetAllAsync([\n    new Contact { Name = \"Charlie\" },\n    new Contact { Name = \"Diana\" }\n]);\n</code></pre> <p>You can also configure <code>CollectionEndpoint</code> to use a custom type derived from <code>ElementEndpoint</code> for elements.</p> <pre><code>var contacts = new CollectionEndpoint&lt;Contact, ContactEndpoint&gt;(client, \"contacts\");\n\n// Create a new entity\nContactEndpoint newContact = await contacts.CreateAsync(new Contact { Name = \"John Doe\" });\n\n// Get an element by ID\nContactEndpoint contact = contacts[\"123\"];\n</code></pre> <pre><code>CollectionEndpoint&lt;Contact&gt; contacts = new CollectionEndpointImpl&lt;&gt;(client, \"contacts\", Contact.class);\n\n// Read all entities in the collection\nList&lt;Contact&gt; allContacts = contacts.readAll();\n\n// Read a range of entities\nPartialResponse&lt;Contact&gt; someContacts = contacts.readRange(Range.ofLength(0, 50));\n\n// Create a new entity\nElementEndpoint&lt;Contact&gt; newContact = contacts.create(new Contact(\"John Doe\"));\n\n// Get an element by ID\nElementEndpoint&lt;Contact&gt; contact = contacts.get(\"123\");\n\n// Update multiple entities\ncontacts.createAll(List.of(\n    new Contact(\"Alice\"),\n    new Contact(\"Bob\")\n));\n\n// Replace entire collection\ncontacts.setAll(List.of(\n    new Contact(\"Charlie\"),\n    new Contact(\"Diana\")\n));\n</code></pre> <p>You can also use <code>GenericCollectionEndpointImpl</code> to use a custom type derived from <code>ElementEndpoint</code> for elements.</p> <pre><code>GenericCollectionEndpoint&lt;Contact, ContactEndpoint&gt; contacts = new GenericCollectionEndpointImpl&lt;&gt;(client, \"contacts\", Contact.class, (ref, uri) -&gt; new ContactEndpoint(ref, uri));\n\n// Create a new entity\nContactEndpoint newContact = contacts.create(new Contact(\"John Doe\"));\n\n// Get an element by ID\nContactEndpoint contact = contacts.get(\"123\");\n</code></pre> <pre><code>val contacts = CollectionEndpointImpl(client, \"contacts\", Contact::class.java)\n\n// Read all entities in the collection\nval allContacts = contacts.readAll()\n\n// Read a range of entities\nval someContacts = contacts.readRange(Range.ofLength(0, 50))\n\n// Create a new entity\nval newContact = contacts.create(Contact(\"John Doe\"))\n\n// Get an element by ID\nval contact = contacts[\"123\"]\n\n// Update multiple entities\ncontacts.createAll(listOf(\n    Contact(\"Alice\"),\n    Contact(\"Bob\")\n))\n\n// Replace entire collection\ncontacts.setAll(listOf(\n    Contact(\"Charlie\"),\n    Contact(\"Diana\")\n))\n</code></pre> <p>You can also use <code>GenericCollectionEndpointImpl</code> to use a custom type derived from <code>ElementEndpoint</code> for elements.</p> <pre><code>val contacts = GenericCollectionEndpointImpl(client, \"contacts\", Contact::class.java, ::ContactEndpoint)\n\n// Create a new entity\nval newContact: ContactEndpoint = contacts.create(Contact(\"John Doe\"))\n\n// Get an element by ID\nval contact: ContactEndpoint = contacts[\"123\"]\n</code></pre> <pre><code>const contacts = new CollectionEndpoint&lt;Contact&gt;(client, \"contacts\");\n\n// Read all entities in the collection\nconst allContacts = await contacts.readAll();\n\n// Create a new entity\nconst newContact = await contacts.create({ name: \"John Doe\" });\n\n// Get an element by ID\nconst contact = contacts.get(\"123\");\n\n// Update multiple entities\nawait contacts.createAll([\n    { name: \"Alice\" },\n    { name: \"Bob\" }\n]);\n\n// Replace entire collection\nawait contacts.setAll([\n    { name: \"Charlie\" },\n    { name: \"Diana\" }\n]);\n</code></pre> <p>You can also use <code>GenericCollectionEndpoint</code> to use a custom type derived from <code>ElementEndpoint</code> for elements.</p> <pre><code>const contacts = new GenericCollectionEndpoint&lt;Contact, ContactEndpoint&gt;(client, \"contacts\", ContactEndpoint);\n\n// Create a new entity\nconst newContact: ContactEndpoint = await contacts.create({ name: \"John Doe\" });\n\n// Get an element by ID\nconst contact: ContactEndpoint = contacts.get(\"123\");\n</code></pre>"},{"location":"endpoints/generic/element/","title":"Element endpoint","text":"<p>Endpoint for an individual resource.</p> Method Input Result HTTP Verb Description Exists - Boolean <code>HEAD</code> Determines whether the element currently exists. Read - Entity <code>GET</code> Returns the entity. Set Entity Entity <code>PUT</code> Sets/replaces the entity. Merge Entity Entity <code>PATCH</code> Modifies the existing entity by merging changes. Delete - - <code>DELETE</code> Deletes the element."},{"location":"endpoints/generic/element/#usage","title":"Usage","text":"C#JavaKotlinTypeScript <pre><code>var contact = new ElementEndpoint&lt;Contact&gt;(client, \"contacts/123\");\n\n// Check if the element exists\nbool exists = await contact.ExistsAsync();\n\n// Read the entity\nContact entity = await contact.ReadAsync();\n\n// Update the entire entity\nawait contact.SetAsync(new Contact { Name = \"Jane Doe\", Email = \"jane@example.com\" });\n\n// Partially update the entity\nawait contact.MergeAsync(new { Email = \"newemail@example.com\" });\n\n// Delete the element\nawait contact.DeleteAsync();\n</code></pre> <pre><code>ElementEndpoint&lt;Contact&gt; contact = new ElementEndpointImpl&lt;&gt;(client, \"contacts/123\", Contact.class);\n\n// Check if the element exists\nboolean exists = contact.exists();\n\n// Read the entity\nContact entity = contact.read();\n\n// Update the entire entity\ncontact.set(new Contact(\"Jane Doe\", \"jane@example.com\"));\n\n// Partially update the entity\nMap&lt;String, Object&gt; updates = Map.of(\"email\", \"newemail@example.com\");\ncontact.merge(updates);\n\n// Delete the element\ncontact.delete();\n</code></pre> <pre><code>val contact = ElementEndpointImpl(client, \"contacts/123\", Contact::class.java)\n\n// Check if the element exists\nval exists = contact.exists()\n\n// Read the entity\nval entity = contact.read()\n\n// Update the entire entity\ncontact.set(Contact(\"Jane Doe\", \"jane@example.com\"))\n\n// Partially update the entity\ncontact.merge(mapOf(\"email\" to \"newemail@example.com\"))\n\n// Delete the element\ncontact.delete()\n</code></pre> <pre><code>const contact = new ElementEndpoint&lt;Contact&gt;(client, \"contacts/123\");\n\n// Check if the element exists\nconst exists = await contact.exists();\n\n// Read the entity\nconst entity = await contact.read();\n\n// Update the entire entity\nawait contact.set({ name: \"Jane Doe\", email: \"jane@example.com\" });\n\n// Partially update the entity\nawait contact.merge({ email: \"newemail@example.com\" });\n\n// Delete the element\nawait contact.delete();\n</code></pre>"},{"location":"endpoints/generic/indexer/","title":"Indexer endpoint","text":"<p>Endpoint that addresses child endpoints by ID.</p> Method Input Result HTTP Verb Description Get ID Endpoint - Get an Element endpoint for a specific child element."},{"location":"endpoints/generic/indexer/#usage","title":"Usage","text":"C#JavaKotlinTypeScript <pre><code>var users = new IndexerEndpoint&lt;UserEndpoint&gt;(client, \"users\");\n\n// Get a child endpoint by ID\nUserEndpoint user = users[\"123\"];\n\n// Use the child endpoint\nUser userData = await user.ReadAsync();\n</code></pre> <pre><code>IndexerEndpoint&lt;UserEndpoint&gt; users = new IndexerEndpointImpl&lt;&gt;(client, \"users\", (ref, uri) -&gt; new UserEndpoint(ref, uri));\n\n// Get a child endpoint by ID\nUserEndpoint user = users.get(\"123\");\n\n// Use the child endpoint\nUser userData = user.read();\n</code></pre> <pre><code>val users = IndexerEndpointImpl(client, \"users\", ::UserEndpoint)\n\n// Get a child endpoint by ID\nval user = users[\"123\"]\n\n// Use the child endpoint\nval userData = user.read()\n</code></pre> <pre><code>const users = new IndexerEndpoint&lt;UserEndpoint&gt;(client, \"users\");\n\n// Get a child endpoint by ID\nconst user = users.get(\"123\");\n\n// Use the child endpoint\nconst userData = await user.read();\n</code></pre>"},{"location":"endpoints/raw/blob/","title":"Blob endpoint","text":"<p>Endpoint for a binary blob that can be downloaded or uploaded.</p> Method Input Result HTTP Verb Description Download - Binary data <code>GET</code> Downloads the blob's content. Upload Binary data - <code>PUT</code> Uploads content for the blob."},{"location":"endpoints/raw/blob/#usage","title":"Usage","text":"C#JavaKotlinTypeScript <pre><code>var avatar = new BlobEndpoint(client, \"users/123/avatar\");\n\n// Download to a stream\nStream data = await avatar.DownloadAsync();\n\n// Or download to a file\nawait avatar.DownloadAsync(\"avatar.jpg\");\n\n// Upload from a file\nawait avatar.UploadFromAsync(\"new-avatar.jpg\");\n\n// Or upload from a stream\nusing var fileStream = File.OpenRead(\"new-avatar.jpg\");\nawait avatar.UploadFromAsync(fileStream, mimeType: \"image/jpeg\");\n</code></pre> <pre><code>BlobEndpoint avatar = new BlobEndpointImpl(client, \"users/123/avatar\");\n\n// Download to a stream\nInputStream data = avatar.download();\n\n// Or download to a file\navatar.download(\"avatar.jpg\");\n\n// Upload from a file\navatar.uploadFrom(\"new-avatar.jpg\");\n\n// Or upload from a stream\ntry (InputStream fileStream = new FileInputStream(\"new-avatar.jpg\")) {\n    avatar.uploadFrom(fileStream, \"image/jpeg\");\n}\n</code></pre> <pre><code>val avatar = BlobEndpointImpl(client, \"users/123/avatar\")\n\n// Download to a stream\nval data = avatar.download()\n\n// Or download to a file\navatar.download(\"avatar.jpg\")\n\n// Upload from a file\navatar.uploadFrom(\"new-avatar.jpg\")\n\n// Or upload from a stream\nFileInputStream(\"new-avatar.jpg\").use { fileStream -&gt;\n    avatar.uploadFrom(fileStream, mimeType = \"image/jpeg\")\n}\n</code></pre> <pre><code>const avatar = new BlobEndpoint(client, \"users/123/avatar\");\n\n// Download binary data\nconst data = await avatar.download();\n\n// Upload from a file\nconst file = new File([data], \"new-avatar.jpg\", { type: \"application/jpeg\" });\nawait avatar.uploadFrom(file);\n\n// Or upload from a stream\nconst blob = new Blob([data], { type: \"image/jpeg\" });\nawait avatar.uploadFrom(blob);\n</code></pre>"},{"location":"endpoints/raw/upload/","title":"Upload endpoint","text":"<p>Endpoint that accepts binary uploads.</p> Method Input Result HTTP Verb Description Upload Binary data - <code>POST</code> Uploads data to the endpoint."},{"location":"endpoints/raw/upload/#usage","title":"Usage","text":"C#JavaKotlinTypeScript <pre><code>var attachments = new UploadEndpoint(client, \"issues/456/attachments\");\n\n// Upload from a file\nawait attachments.UploadFromAsync(\"document.pdf\");\n\n// Or upload from a stream\nusing var fileStream = File.OpenRead(\"document.pdf\");\nawait attachments.UploadFromAsync(fileStream, mimeType: \"application/pdf\");\n</code></pre> <pre><code>UploadEndpoint attachments = new UploadEndpointImpl(client, \"issues/456/attachments\");\n\n// Upload from a file\nattachments.uploadFrom(\"document.pdf\");\n\n// Or upload from a stream\ntry (InputStream fileStream = new FileInputStream(\"document.pdf\")) {\n    attachments.uploadFrom(fileStream, \"application/pdf\");\n}\n</code></pre> <pre><code>val attachments = UploadEndpointImpl(client, \"issues/456/attachments\")\n\n// Upload from a file\nattachments.uploadFrom(\"document.pdf\")\n\n// Or upload from a stream\nFileInputStream(\"document.pdf\").use { fileStream -&gt;\n    attachments.uploadFrom(fileStream, mimeType = \"application/pdf\")\n}\n</code></pre> <pre><code>const attachments = new UploadEndpoint(client, \"issues/456/attachments\");\n\n// Upload from a file\nconst file = new File([data], \"document.pdf\", { type: \"application/pdf\" });\nawait attachments.uploadFrom(file);\n\n// Or upload from a stream\nconst blob = new Blob([data], { type: \"application/pdf\" });\nawait attachments.uploadFrom(blob);\n</code></pre>"},{"location":"endpoints/reactive/polling/","title":"Polling endpoint","text":"<p>Endpoint for a resource that can be polled for state changes.</p> Method Input Result HTTP Verb Description Get observable - Entity stream <code>GET</code> Provides an observable stream of entity states. Exists - Boolean <code>HEAD</code> Determines whether the element currently exists. Read - Entity <code>GET</code> Returns the entity. Set Entity Entity <code>PUT</code> Sets/replaces the entity. Merge Entity Entity <code>PATCH</code> Modifies the existing entity by merging changes. Delete - - <code>DELETE</code> Deletes the element. <p>Extends Element endpoint</p>"},{"location":"endpoints/reactive/polling/#usage","title":"Usage","text":"C#JavaKotlin <pre><code>var status = new PollingEndpoint&lt;Status&gt;(client, \"status\");\n\n// Poll for state changes\nIObservable&lt;Status&gt; stream = status.GetObservable(TimeSpan.FromSeconds(5));\nstream.Subscribe(x =&gt; Console.WriteLine($\"Status: {x.State}\"));\n\n// Use as regular element endpoint\nStatus current = await status.ReadAsync();\nawait status.SetAsync(new Status { State = \"active\" });\n</code></pre> <pre><code>PollingEndpoint&lt;Status&gt; status = new PollingEndpointImpl&lt;&gt;(client, \"status\", Status.class);\n\n// Poll for state changes\nObservable&lt;Status&gt; stream = status.getObservable(Duration.ofSeconds(5));\nstream.subscribe(x -&gt; System.out.println(\"Status: \" + x.getState()));\n\n// Use as regular element endpoint\nStatus current = status.read();\nstatus.set(new Status(\"active\"));\n</code></pre> <pre><code>val status = PollingEndpointImpl(client, \"status\", Status::class.java)\n\n// Poll for state changes\nval stream = status.getObservable(Duration.ofSeconds(5))\nstream.subscribe { x -&gt; println(\"Status: ${x.state}\") }\n\n// Use as regular element endpoint\nval current = status.read()\nstatus.set(Status(\"active\"))\n</code></pre>"},{"location":"endpoints/reactive/streaming-collection/","title":"Streaming Collection endpoint","text":"<p>Endpoint for a collection of entities observable as an append-only stream using long-polling.</p> Method Input Result HTTP Verb Description Get observable - Entity stream <code>GET</code> Provides an observable stream of elements. Get ID / Entity Endpoint - Get an Element endpoint for a specific child element. Read all - Entities <code>GET</code> Returns all entities in the collection. Read range Range Entities <code>GET</code> Returns all entities within a specific range of the collection. Create Entity - <code>POST</code> Adds an entity as a new element to the collection. Create All Entities - <code>PATCH</code> Adds (or updates) multiple entities as elements in the collection. Set All Entities - <code>PUT</code> Replaces the entire content of the collection with new entities. <p>Extends Collection endpoint</p>"},{"location":"endpoints/reactive/streaming-collection/#usage","title":"Usage","text":"C#JavaKotlin <pre><code>var messages = new StreamingCollectionEndpoint&lt;Message&gt;(client, \"messages\");\n\n// Subscribe to new messages\nIObservable&lt;Message&gt; stream = messages.GetObservable();\nstream.Subscribe(m =&gt; Console.WriteLine($\"New message: {m.Text}\"));\n\n// Use as regular collection endpoint\nList&lt;Message&gt; all = await messages.ReadAllAsync();\nawait messages.CreateAsync(new Message { Text = \"Hello!\" });\n</code></pre> <p>You can also configure <code>CollectionEndpoint</code> to use a custom type derived from <code>ElementEndpoint</code> for elements.</p> <pre><code>var messages = new StreamingCollectionEndpoint&lt;Message, MessageEndpoint&gt;(client, \"messages\");\n</code></pre> <pre><code>StreamingCollectionEndpoint&lt;Message&gt; messages = new StreamingCollectionEndpointImpl&lt;&gt;(client, \"messages\", Message.class);\n\n// Subscribe to new messages\nObservable&lt;Message&gt; stream = messages.getObservable();\nstream.subscribe(x -&gt; System.out.println(\"New message: \" + x.getText()));\n\n// Use as regular collection endpoint\nList&lt;Message&gt; all = messages.readAll();\nmessages.create(new Message(\"Hello!\"));\n</code></pre> <p>You can also use <code>GenericStreamingCollectionEndpointImpl</code> to use a custom type derived from <code>ElementEndpoint</code> for elements.</p> <pre><code>GenericStreamingCollectionEndpoint&lt;Message, MessageEndpoint&gt; messages = new GenericStreamingCollectionEndpointImpl&lt;&gt;(client, \"messages\", Message.class, (ref, uri) -&gt; new MessageEndpoint(ref, uri));\n</code></pre> <p><pre><code>val messages = StreamingCollectionEndpointImpl(client, \"messages\", Message::class.java)\n\n// Subscribe to new messages\nval stream = messages.getObservable()\nstream.subscribe { x -&gt; println(\"New message: ${x.text}\") }\n\n// Use as regular collection endpoint\nval all = messages.readAll()\nmessages.create(Message(\"Hello!\"))\n</code></pre> <pre><code>You can also use `GenericStreamingCollectionEndpointImpl` to use a custom type derived from `ElementEndpoint` for [elements](../generic/element.md).\n\n```kotlin\nval messages = GenericStreamingCollectionEndpoint(client, \"messages\", Message::class.java, ::MessageEndpoint)\n</code></pre></p>"},{"location":"endpoints/reactive/streaming/","title":"Streaming endpoint","text":"<p>Endpoint for a stream of entities using a persistent HTTP connection.</p> Method Input Result HTTP Verb Description Get observable - Entity stream <code>GET</code> Provides an observable stream of entities."},{"location":"endpoints/reactive/streaming/#usage","title":"Usage","text":"C#JavaKotlin <pre><code>var events = new StreamingEndpoint&lt;Event&gt;(client, \"events\");\n\n// Subscribe to the stream\nIObservable&lt;Event&gt; stream = events.GetObservable();\nstream.Subscribe(x =&gt; Console.WriteLine($\"Event: {x.Type} - {x.Message}\"));\n</code></pre> <pre><code>StreamingEndpoint&lt;Event&gt; events = new StreamingEndpointImpl&lt;&gt;(client, \"events\", Event.class);\n\n// Subscribe to the stream\nObservable&lt;Event&gt; stream = events.getObservable();\nstream.subscribe(x -&gt; System.out.println(\"Event: \" + x.getType() + \" - \" + x.getMessage()));\n</code></pre> <pre><code>val events = StreamingEndpointImpl(client, \"events\", Event::class.java)\n\n// Subscribe to the stream\nval stream = events.getObservable()\nstream.subscribe { x -&gt; println(\"Event: ${x.type} - ${x.message}\") }\n</code></pre>"},{"location":"endpoints/rpc/action/","title":"Action endpoint","text":"<p>RPC endpoint that is invoked with no input or output.</p> Method Input Result HTTP Verb Description Invoke - - <code>POST</code> Invokes the action."},{"location":"endpoints/rpc/action/#usage","title":"Usage","text":"C#JavaKotlinTypeScript <pre><code>var refresh = new ActionEndpoint(client, \"refresh\");\n\n// Invoke the action\nawait refresh.InvokeAsync();\n</code></pre> <pre><code>ActionEndpoint refresh = new ActionEndpoint(client, \"refresh\");\n\n// Invoke the action\nrefresh.invoke();\n</code></pre> <pre><code>val refresh = ActionEndpoint(client, \"refresh\")\n\n// Invoke the action\nrefresh.invoke()\n</code></pre> <pre><code>const refresh = new ActionEndpoint(client, \"refresh\");\n\n// Invoke the action\nawait refresh.invoke();\n</code></pre>"},{"location":"endpoints/rpc/consumer/","title":"Consumer endpoint","text":"<p>RPC endpoint that takes an entity as input when invoked.</p> Method Input Result HTTP Verb Description Invoke Entity - <code>POST</code> Sends the entity to the consumer."},{"location":"endpoints/rpc/consumer/#usage","title":"Usage","text":"C#JavaKotlinTypeScript <pre><code>var logger = new ConsumerEndpoint&lt;LogEntry&gt;(client, \"log\");\n\n// Invoke with input\nawait logger.InvokeAsync(new LogEntry { Message = \"Hello, world!\", Level = \"Info\" });\n</code></pre> <pre><code>ConsumerEndpoint&lt;LogEntry&gt; logger = new ConsumerEndpoint&lt;&gt;(client, \"log\", LogEntry.class);\n\n// Invoke with input\nlogger.invoke(new LogEntry(\"Hello, world!\", \"Info\"));\n</code></pre> <pre><code>val logger = ConsumerEndpoint(client, \"log\", LogEntry::class.java)\n\n// Invoke with input\nlogger.invoke(LogEntry(\"Hello, world!\", \"Info\"))\n</code></pre> <pre><code>const logger = new ConsumerEndpoint&lt;LogEntry&gt;(client, \"log\");\n\n// Invoke with input\nawait logger.invoke({ message: \"Hello, world!\", level: \"Info\" });\n</code></pre>"},{"location":"endpoints/rpc/function/","title":"Function endpoint","text":"<p>RPC endpoint that takes an entity as input and returns another entity as output when invoked.</p> Method Input Result HTTP Verb Description Invoke Entity Entity <code>POST</code> Invokes the function."},{"location":"endpoints/rpc/function/#usage","title":"Usage","text":"C#JavaKotlinTypeScript <pre><code>var calculator = new FunctionEndpoint&lt;Calculation, Result&gt;(client, \"calculate\");\n\n// Invoke with input and get output\nResult result = await calculator.InvokeAsync(new Calculation { X = 10, Y = 5, Op = \"add\" });\n</code></pre> <pre><code>FunctionEndpoint&lt;Calculation, Result&gt; calculator = new FunctionEndpoint&lt;&gt;(client, \"calculate\", Calculation.class, Result.class);\n\n// Invoke with input and get output\nResult result = calculator.invoke(new Calculation(10, 5, \"add\"));\n</code></pre> <pre><code>val calculator = FunctionEndpoint(client, \"calculate\", Calculation::class.java, Result::class.java)\n\n// Invoke with input and get output\nval result = calculator.invoke(Calculation(10, 5, \"add\"))\n</code></pre> <pre><code>const calculator = new FunctionEndpoint&lt;Calculation, Result&gt;(client, \"calculate\");\n\n// Invoke with input and get output\nconst result = await calculator.invoke({ x: 10, y: 5, op: \"add\" });\n</code></pre>"},{"location":"endpoints/rpc/producer/","title":"Producer endpoint","text":"<p>RPC endpoint that returns an entity as output when invoked.</p> Method Input Result HTTP Verb Description Invoke - Entity <code>POST</code> Gets an entity from the producer."},{"location":"endpoints/rpc/producer/#usage","title":"Usage","text":"C#JavaKotlinTypeScript <pre><code>var generator = new ProducerEndpoint&lt;Token&gt;(client, \"generate-token\");\n\n// Invoke and get output\nToken token = await generator.InvokeAsync();\n</code></pre> <pre><code>ProducerEndpoint&lt;Token&gt; generator = new ProducerEndpoint&lt;&gt;(client, \"generate-token\", Token.class);\n\n// Invoke and get output\nToken token = generator.invoke();\n</code></pre> <pre><code>val generator = ProducerEndpoint(client, \"generate-token\", Token::class.java)\n\n// Invoke and get output\nval token = generator.invoke()\n</code></pre> <pre><code>const generator = new ProducerEndpoint&lt;Token&gt;(client, \"generate-token\");\n\n// Invoke and get output\nconst token = await generator.invoke();\n</code></pre>"},{"location":"error-handling/","title":"Exception mapping","text":"<p>TypedRest maps non-success HTTP Status (4xx and 5xx) to exceptions/errors. The following mappings are applied by default:</p> HTTP Status Code .NET Exception JavaScript Error 400 Bad Request <code>InvalidDataException</code> <code>BadRequestError</code> 401 Unauthorized <code>AuthenticationException</code> <code>AuthenticationError</code> 403 Forbidden <code>UnauthorizedAccessException</code> <code>AuthorizationError</code> 404 NotFound or 410 Gone <code>KeyNotFoundException</code> <code>NotFoundError</code> 408 Request Timeout <code>TimeoutException</code> <code>TimeoutError</code> 409 Conflict <code>InvalidOperationException</code> <code>ConflictError</code> 412 Precondition Failed <code>InvalidOperationException</code> <code>ConcurrencyError</code> 416 Range Not Satisfiable <code>InvalidOperationException</code> <code>RangeError</code> other <code>HttpRequestException</code> <code>HttpError</code>"},{"location":"link-handling/","title":"Link handling","text":"<p>TypedRest supports a variety of different ways to establish links between endpoints:</p> <ul> <li>Hard-coded relative URIs</li> <li>URI templates for dynamic URL construction</li> <li>Links via HTTP Link Header transmitted in response headers</li> <li>Links encoded in resources via HAL for hypermedia-driven APIs</li> </ul>"},{"location":"link-handling/#link-resolution","title":"Link resolution","text":"<p>All endpoints provide methods for resolving links:</p> C#JavaKotlinTypeScript <pre><code>// Resolves all links with a specific relation type.\nIReadOnlyList&lt;(Uri uri, string? title)&gt; GetLinks(string rel);\n\n// Resolves a single link with a specific relation type.\nUri Link(string rel);\n\n// Resolves a link template with a specific relation type.\nUri LinkTemplate(string rel, IDictionary&lt;string, object&gt; variables);\n</code></pre> <pre><code>// Resolves all links with a specific relation type.\nList&lt;Pair&lt;URI, String&gt;&gt; getLinks(String rel);\n\n// Resolves a single link with a specific relation type.\nURI link(String rel);\n\n// Resolves a link template with a specific relation type.\nURI linkTemplate(String rel, Map&lt;String, Object&gt; variables);\n</code></pre> <pre><code>// Resolves all links with a specific relation type.\nfun getLinks(rel: String): List&lt;Pair&lt;URI, String?&gt;&gt;\n\n// Resolves a single link with a specific relation type.\nfun link(rel: String): URI\n\n// Resolves a link template with a specific relation type.\nfun linkTemplate(rel: String, variables: Map&lt;String, Any&gt;): URI\n</code></pre> <pre><code>// Resolves all links with a specific relation type.\ngetLinks(rel: string): { uri: URL; title?: string; }[];\n\n// Resolves a single link with a specific relation type.\nlink(rel: string): URL;\n\n// Resolves a link template with a specific relation type.\nlinkTemplate(rel: string, variables: { [key: string]: any; }): URL;\n</code></pre> <p>These methods use cached data from the last response. On cache miss, they perform a lazy lookup using HTTP <code>HEAD</code>.</p>"},{"location":"link-handling/hal/","title":"HAL (Hypertext Application Language)","text":"<p>TypedRest supports extracting links from response bodies using the HAL specification. HAL provides a consistent format for embedding links and embedded resources within JSON responses.</p>"},{"location":"link-handling/hal/#hal-format","title":"HAL format","text":"<p>HAL adds a <code>_links</code> object to JSON responses containing links organized by relation type:</p> <pre><code>{\n    \"id\": 123,\n    \"name\": \"John Doe\",\n    \"_links\": {\n        \"self\": { \"href\": \"/users/123\" },\n        \"orders\": { \"href\":  \"/users/123/orders\" },\n        \"search\": { \"href\":  \"/users/{id}\", \"templated\": true }\n    }\n}\n</code></pre>"},{"location":"link-handling/hal/#content-type","title":"Content type","text":"<p>TypedRest recognizes HAL responses by the <code>application/hal+json</code> content type:</p> <p>When this content type is present, TypedRest automatically parses the <code>_links</code> object and makes the links available through the standard link resolution methods.</p>"},{"location":"link-handling/hal/#using-hal-links","title":"Using HAL links","text":"<p>After receiving a HAL response, you can resolve links just like with HTTP Link headers:</p> C#JavaKotlinTypeScript <pre><code>await endpoint.ReadAsync();\n\n// Resolve a single link\nUri ordersUri = endpoint.Link(\"orders\");\n\n// Resolve a templated link\nUri userUri = endpoint.LinkTemplate(\"search\", new { id = \"456\" });\n</code></pre> <pre><code>endpoint.read();\n\n// Resolve a single link\nURI ordersUri = endpoint.link(\"orders\");\n\n// Resolve a templated link\nURI userUri = endpoint.linkTemplate(\"search\", Map.of(\"id\", \"456\"));\n</code></pre> <pre><code>endpoint.read()\n\n// Resolve a single link\nval ordersUri = endpoint.link(\"orders\")\n\n// Resolve a templated link\nval userUri = endpoint.linkTemplate(\"search\", mapOf(\"id\" to \"456\"))\n</code></pre> <pre><code>await endpoint.read();\n\n// Resolve a single link\nconst ordersUri = endpoint.link(\"orders\");\n\n// Resolve a templated link\nconst userUri = endpoint.linkTemplate(\"search\", { id: \"456\" });\n</code></pre>"},{"location":"link-handling/hal/#multiple-links","title":"Multiple links","text":"<p>HAL supports multiple links for the same relation type using an array:</p> <pre><code>{\n    \"_links\": {\n        \"item\": [\n            { \"href\": \"/items/1\", \"title\": \"First Item\" },\n            { \"href\": \"/items/2\", \"title\": \"Second Item\" }\n        ]\n    }\n}\n</code></pre> <p>Retrieve all links with <code>GetLinks</code>:</p> C#JavaKotlinTypeScript <pre><code>var items = endpoint.GetLinks(\"item\");\nforeach (var (uri, title) in items)\n{\n    Console.WriteLine($\"{title}: {uri}\");\n}\n</code></pre> <pre><code>List&lt;Link&gt; items = endpoint.getLinks(\"item\");\nfor (Link link : items) {\n    System.out.println(link.getTitle() + \": \" + link.getUri());\n}\n</code></pre> <pre><code>val items = endpoint.getLinks(\"item\")\nfor (link in items) {\n    println(\"${link.title}: ${link.uri}\")\n}\n</code></pre> <pre><code>const items = endpoint.getLinks(\"item\");\nfor (const { uri, title } of items) {\n    console.log(`${title}: ${uri}`);\n}\n</code></pre>"},{"location":"link-handling/hal/#templated-links","title":"Templated links","text":"<p>HAL links can be marked as templates with the <code>templated</code> property:</p> <pre><code>{\n    \"_links\": {\n        \"find\": {\n            \"href\": \"/users{?name,email}\",\n            \"templated\": true\n        }\n    }\n}\n</code></pre> C#JavaKotlinTypeScript <pre><code>var findUri = endpoint.LinkTemplate(\"find\", new { name = \"John\", email = \"john@example.com\" });\n// Result: /users?name=John&amp;email=john%40example.com\n</code></pre> <pre><code>URI findUri = endpoint.linkTemplate(\"find\", Map.of(\"name\", \"John\", \"email\", \"john@example.com\"));\n// Result: /users?name=John&amp;email=john%40example.com\n</code></pre> <pre><code>val findUri = endpoint.linkTemplate(\"find\", mapOf(\"name\" to \"John\", \"email\" to \"john@example.com\"))\n// Result: /users?name=John&amp;email=john%40example.com\n</code></pre> <pre><code>const findUri = endpoint.linkTemplate(\"find\", { name: \"John\", email: \"john@example.com\" });\n// Result: /users? name=John&amp;email=john%40example.com\n</code></pre>"},{"location":"link-handling/link-header/","title":"HTTP Link header","text":"<p>TypedRest can extract links from HTTP <code>Link</code> headers as defined in RFC 8288. This enables HATEOAS-style navigation where the server provides links to related resources in response headers.</p>"},{"location":"link-handling/link-header/#header-format","title":"Header format","text":"<p>The HTTP <code>Link</code> header follows this format:</p> <pre><code>Link: &lt;target-uri&gt;; rel=\"relation-type\"; title=\"optional title\"\n</code></pre> <p>Multiple links can be specified in a single header, separated by commas:</p> <pre><code>Link: &lt;http://example.com/users&gt;; rel=self, &lt;http://example.com/user/123&gt;; rel=child\n</code></pre>"},{"location":"link-handling/link-header/#extracting-links","title":"Extracting links","text":"<p>TypedRest automatically extracts links from response headers after each request. You can then resolve them:</p> C#JavaKotlinTypeScript <pre><code>// Perform a request\nawait endpoint.ReadAsync();\n\n// Get all links with a specific relation type\nvar links = endpoint.GetLinks(\"child\");\nforeach (var (uri, title) in links)\n{\n    Console.WriteLine($\"URI: {uri}, Title: {title}\");\n}\n\n// Get a single link\nUri collectionUri = endpoint.Link(\"next\");\n</code></pre> <pre><code>// Perform a request\nendpoint.read();\n\n// Get all links with a specific relation type\nList&lt;Link&gt; links = endpoint.getLinks(\"child\");\nfor (Link link : links) {\n    System.out.println(\"URI: \" + link.getUri() + \", Title: \" + link.getTitle());\n}\n\n// Get a single link\nURI collectionUri = endpoint.link(\"next\");\n</code></pre> <pre><code>// Perform a request\nendpoint.read()\n\n// Get all links with a specific relation type\nval links = endpoint.getLinks(\"child\")\nfor (link in links) {\n    println(\"URI: ${link.uri}, Title: ${link.title}\")\n}\n\n// Get a single link\nval collectionUri = endpoint.link(\"next\")\n</code></pre> <pre><code>// Perform a request\nawait endpoint.read();\n\n// Get all links with a specific relation type\nconst links = endpoint.getLinks(\"child\");\nfor (const { uri, title } of links) {\n    console.log(`URI: ${uri}, Title: ${title}`);\n}\n\n// Get a single link\nconst collectionUri = endpoint.link(\"next\");\n</code></pre>"},{"location":"link-handling/link-header/#templated-links","title":"Templated links","text":"<p>TypedRest extends the standard Link header format to support URI templates. Templates are indicated with <code>templated=true</code>:</p> <pre><code>Link: &lt;/users/{id}&gt;; rel=user; templated=true\n</code></pre> <p>This is a non-standard extension, but it allows servers to provide dynamic link templates via headers without needing HAL or another hypermedia format in the response body.</p> C#JavaKotlinTypeScript <pre><code>// Server response:\n// Link: &lt;/users/{id}&gt;; rel=user; templated=true\n\nvar userUri = endpoint.LinkTemplate(\"user\", new { id = \"123\" });\n// Result: http://example.com/users/123\n</code></pre> <pre><code>// Server response:\n// Link: &lt;/users/{id}&gt;; rel=user; templated=true\n\nURI userUri = endpoint.linkTemplate(\"user\", Map.of(\"id\", \"123\"));\n// Result: http://example.com/users/123\n</code></pre> <pre><code>// Server response:\n// Link: &lt;/users/{id}&gt;; rel=user; templated=true\n\nval userUri = endpoint.linkTemplate(\"user\", mapOf(\"id\" to \"123\"))\n// Result: http://example.com/users/123\n</code></pre> <pre><code>// Server response:\n// Link: &lt;/users/{id}&gt;; rel=user; templated=true\n\nconst userUri = endpoint.linkTemplate(\"user\", { id: \"123\" });\n// Result: http://example.com/users/123\n</code></pre>"},{"location":"link-handling/link-header/#link-header-attributes","title":"Link header attributes","text":"<p>The following attributes are supported:</p> Attribute Description <code>rel</code> The relation type (required) <code>title</code> Human-readable title for the link (optional) <code>templated</code> Indicates a URI template when set to <code>true</code> (non-standard)"},{"location":"link-handling/relative-uris/","title":"Relative URIs","text":"<p>The most straightforward way to navigate between endpoints is using hard-coded relative URIs.  When creating child endpoints, you pass a relative URI that is resolved against the parent endpoint's URI.</p>"},{"location":"link-handling/relative-uris/#basic-usage","title":"Basic usage","text":"C#JavaKotlinTypeScript <pre><code>var client = new EntryEndpoint(new Uri(\"http://example.com/api/\"));\nvar contacts = new CollectionEndpoint&lt;Contact&gt;(client, \"contacts\");\n// Results in: http://example.com/api/contacts\n</code></pre> <pre><code>EntryEndpoint client = new EntryEndpoint(URI.create(\"http://example.com/api/\"));\nCollectionEndpoint&lt;Contact&gt; contacts = new CollectionEndpoint&lt;&gt;(client, \"contacts\", Contact.class);\n// Results in: http://example.com/api/contacts\n</code></pre> <pre><code>val client = EntryEndpoint(URI.create(\"http://example.com/api/\"))\nval contacts = CollectionEndpoint(client, \"contacts\", Contact::class.java)\n// Results in: http://example.com/api/contacts\n</code></pre> <pre><code>const client = new EntryEndpoint(new URL(\"http://example.com/api/\"));\nconst contacts = new CollectionEndpoint&lt;Contact&gt;(client, \"contacts\");\n// Results in: http://example.com/api/contacts\n</code></pre>"},{"location":"link-handling/relative-uris/#trailing-slash-pattern","title":"Trailing slash pattern","text":"<p>Standard URI resolution can be tricky when the parent URI doesn't have a trailing slash. Consider:</p> <ul> <li>Base URI: <code>http://example.com/endpoint</code></li> <li>Relative URI: <code>subresource</code></li> <li>Standard resolution: <code>http://example.com/subresource</code> (replaces <code>endpoint</code>)</li> </ul> <p>This is often not the desired behavior. TypedRest provides a non-standard <code>./</code> prefix pattern to handle this:</p> C#JavaKotlinTypeScript <pre><code>var parent = new ElementEndpoint&lt;MyEntity&gt;(client, \"endpoint\");\n// parent.Uri = http://example.com/endpoint\n\n// Without ./ prefix - replaces last segment\nvar child1 = new ActionEndpoint(parent, \"subresource\");\n// child1.Uri = http://example.com/subresource\n\n// With ./ prefix - appends to path\nvar child2 = new ActionEndpoint(parent, \"./subresource\");\n// child2.Uri = http://example.com/endpoint/subresource\n</code></pre> <pre><code>ElementEndpoint&lt;MyEntity&gt; parent = new ElementEndpoint&lt;&gt;(client, \"endpoint\", MyEntity.class);\n// parent.getUri() = http://example.com/endpoint\n\n// Without ./ prefix - replaces last segment\nActionEndpoint child1 = new ActionEndpoint(parent, \"subresource\");\n// child1.getUri() = http://example.com/subresource\n\n// With ./ prefix - appends to path\nActionEndpoint child2 = new ActionEndpoint(parent, \"./subresource\");\n// child2.getUri() = http://example.com/endpoint/subresource\n</code></pre> <pre><code>val parent = ElementEndpoint(client, \"endpoint\", MyEntity::class.java)\n// parent.uri = http://example.com/endpoint\n\n// Without ./ prefix - replaces last segment\nval child1 = ActionEndpoint(parent, \"subresource\")\n// child1.uri = http://example.com/subresource\n\n// With ./ prefix - appends to path\nval child2 = ActionEndpoint(parent, \"./subresource\")\n// child2.uri = http://example.com/endpoint/subresource\n</code></pre> <pre><code>const parent = new ElementEndpoint&lt;MyEntity&gt;(client, \"endpoint\");\n// parent.uri = http://example.com/endpoint\n\n// Without ./ prefix - replaces last segment\nconst child1 = new ActionEndpoint(parent, \"subresource\");\n// child1.uri = http://example.com/subresource\n\n// With ./ prefix - appends to path\nconst child2 = new ActionEndpoint(parent, \"./subresource\");\n// child2.uri = http://example.com/endpoint/subresource\n</code></pre> <p>The <code>./</code> prefix tells TypedRest to ensure a trailing slash on the parent URI before resolving the relative URI. This makes the relative URI resolution behave as if the parent URI was <code>http://example.com/endpoint/</code>.</p>"},{"location":"link-handling/relative-uris/#default-links","title":"Default links","text":"<p>You can also register default links that will be used when the server doesn't provide links for a specific relation type:</p> C#JavaKotlinTypeScript <pre><code>class MyEndpoint : EndpointBase\n{\n    public MyEndpoint(IEndpoint referrer, string relativeUri) \n        : base(referrer, relativeUri)\n    {\n        SetDefaultLink(\"related\", \"./related-resource\");\n    }\n}\n</code></pre> <pre><code>class MyEndpoint extends AbstractEndpoint {\n    public MyEndpoint(Endpoint referrer, String relativeUri) {\n        super(referrer, relativeUri);\n        setDefaultLink(\"related\", \"./related-resource\");\n    }\n}\n</code></pre> <pre><code>class MyEndpoint(referrer: Endpoint, relativeUri: String) : AbstractEndpoint(referrer, relativeUri) {\n    init {\n        setDefaultLink(\"related\", \"./related-resource\")\n    }\n}\n</code></pre> <pre><code>class MyEndpoint extends Endpoint {\n    constructor(referrer:  Endpoint, relativeUri: string) {\n        super(referrer, relativeUri);\n        this.setDefaultLink(\"related\", \"./related-resource\");\n    }\n}\n</code></pre>"},{"location":"link-handling/uri-templates/","title":"URI templates","text":"<p>TypedRest supports URI templates as defined in RFC 6570. URI templates allow you to construct URIs dynamically by substituting variables into a template string.</p>"},{"location":"link-handling/uri-templates/#how-uri-templates-work","title":"How URI templates work","text":"<p>A URI template contains placeholders (variables) that are replaced with actual values at runtime. For example:</p> <ul> <li>Template: <code>/users/{id}</code> with <code>{id:  \"123\"}</code> \u2192 <code>/users/123</code></li> <li>Template: <code>/search{?q,limit}</code> with <code>{q: \"test\", limit: 10}</code> \u2192 <code>/search?q=test&amp;limit=10</code></li> </ul>"},{"location":"link-handling/uri-templates/#server-provided-templates","title":"Server-provided templates","text":"<p>The server can provide URI templates via the HTTP Link header:</p> <pre><code>Link: &lt;/users/{id}&gt;; rel=user; templated=true\n</code></pre> <p>Or in HAL:</p> <pre><code>{\n    \"_links\": {\n        \"user\": {\n            \"href\": \"/users/{id}\",\n            \"templated\": true\n        }\n    }\n}\n</code></pre>"},{"location":"link-handling/uri-templates/#resolving-templates","title":"Resolving templates","text":"<p>Use the <code>LinkTemplate</code> method to resolve a template with variables:</p> C#JavaKotlinTypeScript <pre><code>// After receiving a response with the link template\nvar userUri = endpoint.LinkTemplate(\"user\", new { id = \"123\" });\n// Result: http://example.com/users/123\n\n// With query parameters\nvar searchUri = endpoint.LinkTemplate(\"search\", new { q = \"test\", limit = 10 });\n// Result: http://example.com/search?q=test&amp;limit=10\n\n// Using a dictionary\nvar variables = new Dictionary&lt;string, object&gt; { [\"id\"] = \"123\" };\nvar uri = endpoint.LinkTemplate(\"user\", variables);\n</code></pre> <pre><code>// After receiving a response with the link template\nURI userUri = endpoint.linkTemplate(\"user\", Map.of(\"id\", \"123\"));\n// Result: http://example.com/users/123\n\n// With query parameters\nURI searchUri = endpoint.linkTemplate(\"search\", Map.of(\"q\", \"test\", \"limit\", 10));\n// Result: http://example.com/search?q=test&amp;limit=10\n</code></pre> <pre><code>// After receiving a response with the link template\nval userUri = endpoint.linkTemplate(\"user\", mapOf(\"id\" to \"123\"))\n// Result: http://example.com/users/123\n\n// With query parameters\nval searchUri = endpoint.linkTemplate(\"search\", mapOf(\"q\" to \"test\", \"limit\" to 10))\n// Result: http://example.com/search?q=test&amp;limit=10\n</code></pre> <pre><code>// After receiving a response with the link template\nconst userUri = endpoint.linkTemplate(\"user\", { id: \"123\" });\n// Result: http://example.com/users/123\n\n// With query parameters\nconst searchUri = endpoint.linkTemplate(\"search\", { q: \"test\", limit: 10 });\n// Result: http://example.com/search?q=test&amp;limit=10\n</code></pre>"},{"location":"link-handling/uri-templates/#default-link-templates","title":"Default link templates","text":"<p>You can register default link templates that will be used when the server doesn't provide a template for a specific relation type:</p> C#JavaKotlinTypeScript <pre><code>class MyEndpoint : EndpointBase\n{\n    public MyEndpoint(IEndpoint referrer, string relativeUri) \n        : base(referrer, relativeUri)\n    {\n        // Set a default template for the \"child\" relation\n        SetDefaultLinkTemplate(\"child\", \"./{id}\");\n    }\n}\n</code></pre> <pre><code>class MyEndpoint extends AbstractEndpoint {\n    public MyEndpoint(Endpoint referrer, String relativeUri) {\n        super(referrer, relativeUri);\n        // Set a default template for the \"child\" relation\n        setDefaultLinkTemplate(\"child\", \"./{id}\");\n    }\n}\n</code></pre> <pre><code>class MyEndpoint(referrer: Endpoint, relativeUri: String) : AbstractEndpoint(referrer, relativeUri) {\n    init {\n        // Set a default template for the \"child\" relation\n        setDefaultLinkTemplate(\"child\", \"./{id}\")\n    }\n}\n</code></pre> <pre><code>class MyEndpoint extends Endpoint {\n    constructor(referrer: Endpoint, relativeUri: string) {\n        super(referrer, relativeUri);\n        // Set a default template for the \"child\" relation\n        this.setDefaultLinkTemplate(\"child\", \"./{id}\");\n    }\n}\n</code></pre>"},{"location":"link-handling/uri-templates/#built-in-defaults","title":"Built-in defaults","text":"<p>Collection and Indexer endpoints automatically set a default link template of <code>./{id}</code> for the <code>child</code> relation. This allows you to access individual elements by ID without the server explicitly providing a link template.</p>"},{"location":"serializers/","title":"Serializers","text":"<p>Serializers control how entities are serialized when sending requests and deserialized when receiving responses.</p> <p>TypedRest provides built-in serializers for various transport formats:</p> <ul> <li>JSON</li> <li>BSON</li> <li>XML</li> </ul> <p>You can also create and use custom serializers.</p>"},{"location":"serializers/#inheritance","title":"Inheritance","text":"<p>When creating endpoints, the serializer is automatically inherited from the parent (referrer) endpoint:</p> C#TypeScript <pre><code>var client = new EntryEndpoint(new Uri(\"http://example.com/\"));\nclient.Serializer = new SystemTextJsonSerializer();\n\nvar contacts = new CollectionEndpoint&lt;Contact&gt;(client, relativeUri: \"./contacts\");\n// contacts.Serializer is automatically set to the same SystemTextJsonSerializer\n</code></pre> <pre><code>const client = new EntryEndpoint(new URL(\"http://example.com/\"));\nclient.serializer = new CustomSerializer();\n\nconst contacts = new CollectionEndpoint&lt;Contact&gt;(client, \"./contacts\");\n// contacts.serializer is automatically set to the same CustomSerializer\n</code></pre> <p>This inheritance ensures consistent serialization behavior across your entire endpoint hierarchy.</p>"},{"location":"serializers/bson/","title":"BSON","text":"C# <p>The BSON serializer provides efficient binary serialization using Newtonsoft.Json's BSON support:</p> <pre><code>var endpoint = new EntryEndpoint(\n    new Uri(\"http://example.com/\"),\n    serializer: new BsonSerializer());\n</code></pre> <p>The BSON serializer uses the same Newtonsoft.Json settings as the default JSON serializer:</p> <ul> <li>Camel-case property naming</li> <li>String enums with camel-case naming</li> <li>Null values are not serialized</li> <li>Automatic type name handling</li> </ul>"},{"location":"serializers/json/","title":"JSON","text":"<p>JSON is the default serialization format in TypedRest.</p> C#TypeScript <p>Newtonsoft.Json (Default)</p> <p>The default serializer uses Newtonsoft.Json with the following settings:</p> <ul> <li>Camel-case property naming</li> <li>String enums with camel-case naming</li> <li>Null values are not serialized</li> <li>Automatic type name handling</li> </ul> <pre><code>var endpoint = new EntryEndpoint(new Uri(\"http://example.com/\"));\n// Uses NewtonsoftJsonSerializer by default\n</code></pre> <p>To customize the serializer settings:</p> <pre><code>var endpoint = new EntryEndpoint(\n    new Uri(\"http://example.com/\"),\n    serializer: new NewtonsoftJsonSerializer\n    {\n        SerializerSettings =\n        {\n            DateFormatString = \"yyyy-MM-dd\"\n        }\n    });\n</code></pre> <p>System.Text.Json</p> <p>You can also use the System.Text.Json serializer with the TypedRest.SystemTextJson NuGet package:</p> <p>Note</p> <p>The <code>TypedRest.SystemTextJson</code> package version should match your main <code>TypedRest</code> package version. Both packages follow the same versioning scheme.</p> <p>Default settings:</p> <ul> <li>Web defaults (camel-case property naming)</li> <li>Null values are not serialized when writing</li> </ul> <p>Basic usage:</p> <pre><code>var endpoint = new EntryEndpoint(\n    new Uri(\"http://example.com/\"),\n    serializer: new SystemTextJsonSerializer());\n</code></pre> <p>To customize the serializer options:</p> <pre><code>var endpoint = new EntryEndpoint(\n    new Uri(\"http://example.com/\"),\n    serializer: new SystemTextJsonSerializer\n    {\n        Options =\n        {\n            WriteIndented = true,\n            Converters = {new JsonStringEnumConverter() }\n        }\n    });\n</code></pre> <p>TypeScript uses the native <code>JSON.stringify()</code> and <code>JSON.parse()</code> methods:</p> <pre><code>const endpoint = new EntryEndpoint(new URL(\"http://example.com/\"));\n// Uses JsonSerializer by default\n</code></pre> <p>Custom serializers</p> <p>You can implement the <code>Serializer</code> interface for custom serialization:</p> <pre><code>import { Serializer } from \"typedrest\";\n\nclass MySerializer implements Serializer {\n    readonly supportedMediaTypes = [\"application/json\"];\n\n    serialize&lt;T&gt;(entity: T): string {\n        // Custom serialization logic\n        return JSON.stringify(entity);\n    }\n\n    deserialize&lt;T&gt;(text: string): T {\n        // Custom deserialization logic\n        return JSON.parse(text) as T;\n    }\n}\n\nconst endpoint = new EntryEndpoint(\n    new URL(\"http://example.com/\"),\n    new MySerializer());\n</code></pre>"},{"location":"serializers/xml/","title":"XML","text":"C# <pre><code>var endpoint = new EntryEndpoint(\n    new Uri(\"http://example.com/\"),\n    serializer: new XmlSerializer());\n</code></pre>"},{"location":"setup/","title":"Setup","text":"<p>TypedRest is available for multiple platforms/languages. Please choose one of the following setup guides:</p> <ul> <li>.NET (C#, VB.NET, F#, etc.)</li> <li>Java / Kotlin</li> <li>TypeScript</li> </ul>"},{"location":"setup/dotnet/","title":".NET","text":""},{"location":"setup/dotnet/#dependencies","title":"Dependencies","text":"<p>Add one or more of the following NuGet packages to your project:</p> <p>TypedRest The main TypedRest library.</p> <p>TypedRest.Reactive Adds support for streaming with ReactiveX (Rx) to TypedRest.</p> <p>TypedRest.OAuth Provides an HttpClient DelegatingHandler for OAuth 2.0 / OpenID Connect authentication. This can also be used independently of the other TypedRest packages.</p> <p>TypedRest.CommandLine Build command-line interfaces for TypedRest clients.</p>"},{"location":"setup/dotnet/#dependency-injection","title":"Dependency Injection","text":"<p>If you wish to use TypedRest in an ASP.NET Core web service (or any other kind of service that uses <code>IServiceProvider</code>-based dependency injection) you can use the <code>.AddTypedRest&lt;T&gt;()</code> extension method. This registers the endpoint you specify for dependency injection and connects it with HttpClientFactory.</p>"},{"location":"setup/dotnet/#see-also","title":"See also","text":"<ul> <li>API documentation</li> <li>GitHub repository</li> <li>Sample project</li> </ul>"},{"location":"setup/java/","title":"Java / Kotlin","text":""},{"location":"setup/java/#dependencies","title":"Dependencies","text":"<p>Add one or more of the following Maven artifacts to your project:</p> <p>typedrest The main TypedRest library.</p> <p>typedrest-reactive Adds support for streaming with ReactiveX (Rx). Create endpoints using the types in the <code>net.typedrest.endpoints.reactive</code> package.</p> <p>typedrest-serializers-jackson Adds support for serializing using Jackson instead of kotlinx.serialization. Pass <code>new JacksonJsonSerializer()</code> to the <code>EntryEndpoint</code> constructor.</p> <p>typedrest-serializers-moshi Adds support for serializing using Moshi instead of kotlinx.serialization. Pass <code>new MoshiJsonSerializer()</code> to the <code>EntryEndpoint</code> constructor.</p>"},{"location":"setup/java/#see-also","title":"See also","text":"<ul> <li>API documentation</li> <li>GitHub repository</li> </ul>"},{"location":"setup/typescript/","title":"TypeScript","text":""},{"location":"setup/typescript/#dependencies","title":"Dependencies","text":"<p>Add the <code>typescript</code> NPM package to your project:</p> <pre><code>npm install typedrest --save\n</code></pre>"},{"location":"setup/typescript/#see-also","title":"See also","text":"<ul> <li>API documentation</li> <li>GitHub repository</li> </ul>"}]}